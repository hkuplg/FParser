
-- Definition of Thunk
type Thunk[A] = Unit -> A;

let eval[A] (t : Thunk[A]) : A =
    t ();

-- Maybe definition

data Maybe[A] = Nothing
              | Just A;

-- State definition
type State[S, A] = S -> (A, S);

-- ADT List
data PList[A] = Nil
              | Cons A (Thunk[PList[A]])
              ;

let rec nats (beg : Int) : PList[Int] =
    Cons[Int] beg (\(__ : Unit) -> nats (beg+1));

-- Utilities

let singleton[A] (x : A) : PList[A] =
    Cons[A] x (\(__: Unit) -> (Nil[A]));

let rec map[A, B] (f : A -> B) (l : PList[A]) : PList[B] =
    case l of
        Nil             ->      Nil[B]
     |  Cons x xs       ->      Cons[B] (f x) (\(__ : Unit) -> (map[A, B] f (eval[PList[A]] xs)));

let rec foldl[A, B] (f : B -> A -> B) (z : B) (l : PList[A]) : B =
    case l of
        Nil             ->      z
     |  Cons x xs       ->      foldl[A, B] f (f z x) (eval[PList[A]] xs);

--let rec foldr[A, B] (f : A -> B -> B) (z : B) (l : PList[A]) : B =
--    case l of
--        Nil             ->      z
--     |  Cons x xs       ->      f x (foldr[A, B] f z (eval[PList[A]] xs));

let foldr[A, B] (f : A -> B -> B) (z : B) (l : PList[A]) : B =
    (let rec inner (s : PList[A]) (k : B -> B) : B =
        case s of
            Nil         -> k z
         |  Cons x xs   -> inner (eval[PList[A]] xs) (\(y : B) -> k (f x y));
     inner l (\(x : B) -> x));


let join[A] (l : PList[A]) (j : A) : PList[A] = {
    let rec inner[A] (l : PList[A]) (j : A) : PList[A] =
        case l of
            Nil         -> (Nil[A])
         |  Cons x xs   -> (Cons[A] j (\(__ : Unit) ->
                                (Cons[A] x (\(__ : Unit) -> inner[A] (eval[PList[A]] xs) j))));
    case l of
        Nil         -> (Nil[A])
     |  Cons x xs   -> (Cons[A] x (\(__ : Unit) -> inner[A] (eval[PList[A]] xs) j))
};

let rec concat2[A] (a : PList[A]) (b : PList[A]) : PList[A] =
    case a of
        Nil         ->  b
      | Cons x xs   ->  Cons[A] x (\(__ : Unit) -> (concat2[A] (eval[PList[A]] xs) b));

let rec concat[A] (l : PList[PList[A]]) : PList[A] =
    case l of
        Nil         ->  Nil[A]
     |  Cons x xs   ->  concat2[A] x (concat[A] (eval[PList[PList[A]]] xs));

let rec len[A] (l : PList[A]) : Int =
    case l of
        Nil         ->  0
     |  Cons _ xs   ->  1 + (len[A] (eval[PList[A]] xs));

let isempty[A] (l : PList[A]) : Bool =
    case l of
        Nil         -> True
     |  Cons _ _    -> False;

let first[A] (l : PList[A]) : Maybe[A] =
    case l of
        Nil         -> Nothing[A]
     |  Cons x _    -> Just[A] x;

let rest[A] (l : PList[A]) : Maybe[PList[A]] =
    case l of
        Nil         -> Nothing[PList[A]]
     |  Cons _ xs   -> Just[PList[A]] (eval[PList[A]] xs);

let rec take[A] (n : Int) (l : PList[A]) : PList[A] =
    if n <= 0 then
        (Nil[A])
    else
        case l of
            Nil         ->  Nil[A]
         |  Cons x xs   ->  Cons[A] x (\(__ : Unit) -> (take[A] (n-1) (eval[PList[A]] xs)));

let listToString[A] (l : PList[A]) (tostr : A -> String) : String =
    (let inner = foldl[String, String] (\(b : String) (a : String) -> b.concat(a))
                                       ""
                                       (join[String] (map[A, String] tostr l) ", ");
     "[".concat(inner).concat("]"));

-- ADT String

type PString = PList[Char];

let toString (l : PString) : String =
    foldl[Char, String] (\(b : String) (a : Char) -> b.concat(a.toString())) "" l;

let rec fromString (str : String) : PString =
    if length(str) == 0 then
        (Nil[Char])
    else
        (Cons[Char] str.charAt(0) (\(__ : Unit) -> (fromString str.substring(1))));

let rec charin (c : Char) (str : PString) : Bool =
    case str of
        Nil         ->      False
     |  Cons x xs   ->      if x == c then True else (charin c (eval[PString] xs));

-- Parser type definition

type Parser[A] = PString -> PList[(A, PString)];

-- Primitive Parsers

let result[V] (value : V) : Parser[V] =
    \(inp : PString) -> singleton[(V, PString)] (value, inp);

let zero[V] : Parser[V] =
    \(inp : PString) -> Nil[(V, PString)];

let item : Parser[Char] =
    \(inp : PString) ->
        case inp of
            Nil         ->      Nil[(Char, PString)]
          | Cons c xs   ->      singleton[(Char, PString)] (c, (eval[PString] xs));

-- Combinators

let bind[A, B] (p : Parser[A]) (f : A -> Parser[B]) : Parser[B] =
    \(inp : PString) ->
        concat[(B, PString)]
              (map[(A, PString), PList[(B, PString)]]
                  (\(v : (A, PString)) -> f v._1 v._2) (p inp));

let seq[A, B] (p : Parser[A]) (q : Parser[B]) : Parser[(A, B)] =
    bind[A, (A, B)] p (\(x : A) ->
    bind[B, (A, B)] q (\(y : B) ->
    result[(A, B)] (x, y)));

let choice[A] (p : Parser[A]) (q : Parser[A]) : Parser[A] =
    \(inp : PString) ->
        concat2[(A, PString)] (p inp) (q inp);

let sat (f : Char -> Bool) : Parser[Char] =
    bind[Char, Char] item (\(x : Char) -> if f x then (result[Char] x) else zero[Char]);

let char (x : Char) : Parser[Char] =
    sat (\(y : Char) -> x == y);

let notchar (x : Char) : Parser[Char] =
    sat (\(y : Char) -> x != y);

let digit : Parser[Char] =
    sat (\(x : Char) -> java.lang.Character.isDigit(x));

let upper : Parser[Char] =
    sat (\(x : Char) -> java.lang.Character.isUpperCase(x));

let lower : Parser[Char] =
    sat (\(x : Char) -> java.lang.Character.isLowerCase(x));

let space : Parser[Char] =
    sat (\(x : Char) -> java.lang.Character.isSpaceChar(x));

let whitespace : Parser[Char] =
    sat (\(x : Char) -> java.lang.Character.isWhitespace(x));

let letter : Parser[Char] =
    choice[Char] lower upper;

let alphanum : Parser[Char] =
    choice[Char] letter digit;

-- Issue#116
let noneof (s : PString) : Parser[Char] =
    sat (\(x : Char) -> (charin x s) == False);

--let rec noneof (s : PString) : Parser[Char] =
--    case s of
--        Nil         ->  item
--     |  Cons x xs   ->  choice[Char] (notchar x) (noneof xs);

let rec string (s : PString) : Parser[PString] =
    case s of
        Nil         ->  result (Nil[Char])
     |  Cons x xs   ->
            (let xs = eval[PString] xs;
             bind[Char, PString]    (char x)    (\(dummy1 : Char) ->
             bind[PString, PString] (string xs) (\(dummy2 : PString) ->
             result[PString] (Cons[Char] x (\(__ : Unit) -> xs)))));

--let optional[A] (p : Parser[A]) : Parser[A] =
--    \(inp : PString) ->
--        concat2[(A, PString)] (p inp) (Nil[(A, PString)]);

-- Repetition

let rec many[A] (p : Parser[A]) : Parser[PList[A]] =
    choice[PList[A]] (bind[A, PList[A]] p (\(x : A) ->
                      bind[PList[A], PList[A]] (many[A] p) (\(xs : PList[A]) ->
                      result[PList[A]] (Cons[A] x (\(__ : Unit) -> xs)))))
                     (result[PList[A]] (Nil[A]));

let many1[A] (p : Parser[A]) : Parser[PList[A]] =
    bind[A, PList[A]] p (\(x : A) ->
    bind[PList[A], PList[A]] (many[A] p) (\(xs : PList[A]) ->
    result[PList[A]] (Cons[A] x (\(__ : Unit) -> xs))));

let word : Parser[PString] =
    many1[Char] letter;

let ident : Parser[PString] =
    bind[Char, PString] lower (\(x : Char) ->
    bind[PString, PString] (many[Char] alphanum) (\(xs : PString) ->
    result[PString] (Cons[Char] x (\(__ : Unit) -> xs))));

let natural : Parser[Int] = {
    let evaluate (xs : PList[Char]) =
        foldl[Int, Int] (\(b : Int) (a : Int) -> 10 * b + a)
                        0
                        (map[Char, Int] (\(c : Char) -> java.lang.Character.digit(c, 10)) xs);

    bind[PList[Char], Int] (many1[Char] digit) (\(xs : PList[Char]) -> result[Int] (evaluate xs))
};

let int : Parser[Int] =
    choice[Int] (bind[Char, Int] (char '-') (\(__ : Char) -> bind[Int,Int] natural (\(n : Int) -> result[Int] (0-n))))
              natural;

-- Repetition with seperators

let sepby1[A, B] (p : Parser[A]) (sep : Parser[B]) : Parser[PList[A]] = {
    let rep[A, B] (p : Parser[A]) : Parser[A] =
        bind[B, A] sep (\(s : B) -> bind[A, A] p (\(y : A) -> result[A] y));
    bind[A, PList[A]] p (\(x : A) ->
    bind[PList[A], PList[A]] (many[A] (rep[A, B] p)) (\(xs : PList[A]) ->
    result[PList[A]] (Cons[A] x (\(__ : Unit) -> xs))))
};

let sepby[A, B] (p : Parser[A]) (sep : Parser[B]) : Parser[PList[A]] =
    choice[PList[A]] (sepby1[A, B] p sep) (result[PList[A]] (Nil[A]));


-- More complicated

-- Parses non-empty sequences of items seperated by operators that associate to the left
let chainl1[A] (p : Parser[A]) (op : Parser[A -> A -> A]) : Parser[A] = {
    let fy =
        bind[A -> A -> A, (A -> A -> A, A)] op (\(f : A -> A -> A) ->
        bind[A, (A -> A -> A, A)]           p  (\(y : A) ->
        result[(A -> A -> A, A)] (f, y)));

    bind[A, A]                           p                            (\(x : A) ->
    bind[PList[(A -> A -> A, A)], A]     (many[(A -> A -> A, A)] fy)  (\(fys: PList[(A -> A -> A, A)]) ->
    result[A] (foldl[(A -> A -> A, A), A] (\(x : A) (fy : (A -> A -> A, A)) -> fy._1 x fy._2) x fys)))
};

-- associate to the right
let rec chainr1[A] (p : Parser[A]) (op : Parser[A -> A -> A]) : Parser[A] =
    bind[A, A] p (\(x : A) ->
        choice[A] (bind[A -> A -> A, A] op (\(f : A -> A -> A) ->
                 bind[A, A] (chainr1[A] p op) (\(y : A) -> -- Calculate the result on the right
                 result[A] (f x y))))
                (result[A] x));

let chainl[A] (p : Parser[A]) (op : Parser[A -> A -> A]) (v : A) : Parser[A] =
    choice[A] (chainl1[A] p op) (result[A] v);

let chainr[A] (p : Parser[A]) (op : Parser[A -> A -> A]) (v : A) : Parser[A] =
    choice[A] (chainr1[A] p op) (result[A] v);


-- Improved Laziness (Haven't supported in F2J yet)

-- Pick the first (if exists) result
--let only[A] (p : Parser[A]) : Parser[A] =
--    \(inp : PString) ->
--        case (p inp) of
--            Nil         -> (Nil[(A, PString)])
--         |  Cons x xs   -> (singleton[(A, PString)] x);

-- If doesn't care about lazy evaluation, then this version is fancy
let only[A] (p : Parser[A]) : Parser[A] =
    \(inp : PString) -> take[(A, PString)] 1 (p inp);

-- Lazy choice
let lazychoice[A] (p : Parser[A]) (q : Parser[A]) : Parser[A] =
    only[A] (choice[A] p q);

-- Simple arithmetic expression
-- FIXME: Issue110

let bracket[A, B, C] (open : Parser[A]) (p : Parser[B]) (close : Parser[C]) : Parser[B] =
    bind[A, B] open   (\(o : A) ->
    bind[B, B] p      (\(x : B) ->
    bind[C, B] close  (\(c : C) ->
    result[B] x)));

let operation = {
    let addop (a : Int) (b : Int) : Int = a + b;
    let subop (a : Int) (b : Int) : Int = a - b;
    let mulop (a : Int) (b : Int) : Int = a * b;
    let divop (a : Int) (b : Int) : Int = a / b;

    let add_sub = choice[Int -> Int -> Int]
        (bind[Char, Int -> Int -> Int] (char '+') (\(c : Char) -> result[Int -> Int -> Int] addop))
        (bind[Char, Int -> Int -> Int] (char '-') (\(c : Char) -> result[Int -> Int -> Int] subop));
    let mul_div = choice[Int -> Int -> Int]
        (bind[Char, Int -> Int -> Int] (char '*') (\(c : Char) -> result[Int -> Int -> Int] mulop))
        (bind[Char, Int -> Int -> Int] (char '/') (\(c : Char) -> result[Int -> Int -> Int] divop));

    choice[Int -> Int -> Int] add_sub mul_div

    -- Fancy style
--    foldr[Parser[Int -> Int -> Int], Parser[Int -> Int -> Int]] (choice[Int -> Int -> Int])
--        (bind[Char, Int -> Int -> Int] (char '+') (\(c : Char) -> result[Int -> Int -> Int] addop))
--        (Cons[Parser[Int -> Int -> Int]]
--            (bind[Char, Int -> Int -> Int] (char '-') (\(c : Char) -> result[Int -> Int -> Int] subop))
--            (Cons[Parser[Int -> Int -> Int]]
--                (bind[Char, Int -> Int -> Int] (char '*') (\(c : Char) -> result[Int -> Int -> Int] mulop))
--                (Cons[Parser[Int -> Int -> Int]]
--                    (bind[Char, Int -> Int -> Int] (char '/') (\(c : Char) -> result[Int -> Int -> Int] divop))
--                    (Nil[Parser[Int -> Int -> Int]]))))
};

-- Will throw null pointer exception
--let rec expr : Parser[Int] =
--    chainl1[Int] factor operation
--and factor : Parser[Int] =
--    choice[Int] natural (bracket[Char, Int, Char] (char '(') expr (char ')'));

-- Workaround in Issue#110
-- Unbelievable solution!!!!
let rec expr : Parser[Int] =
    \(s : PString) -> chainl1[Int] factor operation s
and factor : Parser[Int] =
    \(s : PString) -> choice[Int] natural (bracket[Char, Int, Char] (char '(') expr (char ')')) s;

-- Naive XML Parser
data XMLNode = XMLText      PString
             | XMLAttr      (PString, PString)
             | XMLElement   PString PList[XMLNode] PList[XMLNode]
             | XMLCData     PString
             | XMLComment   PString
             ;

let xmlComment : Parser[PList[Char]] =
    bind[PString, PList[Char]]     (string (fromString "<!--")) (\(cstart : PString) ->
    bind[PList[Char], PList[Char]] (many[Char] item) (\(comment : PList[Char]) ->
    bind[PString, PList[Char]]     (string (fromString "-->")) (\(cend : PString) ->
    result[PList[Char]] comment)));

--let xmlSpace : Parser[Unit] =
--    only[Unit]
--        (bind[PList[Char], Unit] (many[Char] whitespace) (\(sp1 : PList[Char]) ->
--         bind[PList[Char], Unit] xmlComment              (\(cmt : PList[Char]) ->
--         bind[PList[Char], Unit] (many[Char] whitespace) (\(sp2 : PList[Char]) ->
--         result[Unit] ()))));
let xmlSpace : Parser[Unit] =
    only[Unit]
        (choice[Unit]
            (bind[PList[Char], Unit] (many[Char] whitespace) (\(__ : PList[Char]) -> result[Unit] ()))
            (bind[PList[Char], Unit] (many[Char] whitespace) (\(sp1 : PList[Char]) ->
             bind[PList[Char], Unit] xmlComment              (\(cmt : PList[Char]) ->
             bind[PList[Char], Unit] (many[Char] whitespace) (\(sp2 : PList[Char]) ->
             result[Unit] ())))));

-- Fancy! <-_<-
--let xmlEscapedChar : Parser[Char] =
--    foldr[Parser[Char], Parser[Char]] (choice[Char])
--        (bind[PString, Char] (string (fromString "&quot;")) (\(__ : PString) -> result[Char] '"'))
--        (Cons[Parser[Char]]
--            (bind[PString, Char] (string (fromString "&apos;")) (\(__ : PString) -> result[Char] '\''))
--            (Cons[Parser[Char]]
--                (bind[PString, Char] (string (fromString "&lt;")) (\(__ : PString) -> result[Char] '<'))
--                (Cons[Parser[Char]]
--                    (bind[PString, Char] (string (fromString "&gt;")) (\(__ : PString) -> result[Char] '>'))
--                    (Cons[Parser[Char]]
--                        (bind[PString, Char] (string (fromString "&amp;")) (\(__ : PString) -> result[Char] '&'))
--                        (Nil[Parser[Char]])))));

-- Normal version
let xmlEscapedChar : Parser[Char] = {
    let quot = bind[PString, Char] (string (fromString "&quot;")) (\(__ : PString) -> result[Char] '"');
    let apos = bind[PString, Char] (string (fromString "&apos;")) (\(__ : PString) -> result[Char] '\'');
    let lt = bind[PString, Char] (string (fromString "&lt;")) (\(__ : PString) -> result[Char] '<');
    let gt = bind[PString, Char] (string (fromString "&gt;")) (\(__ : PString) -> result[Char] '>');
    let amp = bind[PString, Char] (string (fromString "&amp;")) (\(__ : PString) -> result[Char] '&');

    choice[Char]
        quot
        (choice[Char]
            apos
            (choice[Char]
                lt
                (choice[Char]
                    gt
                    amp)))
};

let xmlChar : Parser[Char] =
    choice[Char] xmlEscapedChar (noneof (fromString "\"'<>&"));

let xmlString : Parser[PString] =
    many[Char] xmlChar;

let xmlDoubleQuotedString : Parser[PString] =
    bind[Char, PString]       (char '"')    (\(sstart : Char) ->
    bind[PString, PString]    xmlString     (\(content: PString) ->
    bind[Char, PString]       (char '"')    (\(send : Char) ->
    result[PString] content)));

let xmlSingleQuotedString : Parser[PString] =
    bind[Char, PString]       (char '\'')   (\(sstart : Char) ->
    bind[PString, PString]    xmlString     (\(content: PString) ->
    bind[Char, PString]       (char '\'')   (\(send : Char) ->
    result[PString] content)));

let xmlQuotedString : Parser[PString] =
    choice[PString] xmlDoubleQuotedString xmlSingleQuotedString;

let rec xmlText : Parser[XMLNode] =
    bind[PString, XMLNode] xmlString (\(content : PString) -> result[XMLNode] (XMLText content))

and xmlKey : Parser[PString] =
    word

and xmlAttr : Parser[XMLNode] =
    bind[PString, XMLNode]      xmlKey              (\(key : PString) ->
    bind[Unit, XMLNode]         xmlSpace            (\(sp1 : Unit) ->
    bind[Char, XMLNode]         (char '=')          (\(eq : Char) ->
    bind[Unit, XMLNode]         xmlSpace            (\(sp2 : Unit) ->
    bind[PString, XMLNode]      xmlQuotedString     (\(val : PString) ->
    result[XMLNode] (XMLAttr (key, val)))))))

and xmlAttrs : Parser[PList[XMLNode]] =
    sepby[XMLNode, Unit] xmlAttr xmlSpace

and xmlEndTag (tag : PString) : Parser[Unit] =
    bind[PString, Unit]             (string (fromString "</"))                  (\(__ : PString) ->
    bind[Unit, Unit]                xmlSpace                                    (\(__ : Unit) ->
    bind[PString, Unit]             (string tag)                                (\(__ : PString) ->
    bind[Unit, Unit]                xmlSpace                                    (\(__ : Unit) ->
    bind[Char, Unit]                (char '>')                                  (\(__ : Char) ->
    result[Unit] ())))))

and xmlSimpleElement : Parser[XMLNode] =
    bind[Char, XMLNode]             (char '<')                                  (\(__ : Char) ->
    bind[Unit, XMLNode]             xmlSpace                                    (\(__ : Unit) ->
    bind[PString, XMLNode]          xmlKey                                      (\(tag : PString) ->
    bind[Unit, XMLNode]             xmlSpace                                    (\(__ : Unit) ->
    bind[Char, XMLNode]             (char '>')                                  (\(__ : Char) ->
    bind[Unit, XMLNode]             xmlSpace                                    (\(__ : Unit) ->
    bind[Unit, XMLNode]             (xmlEndTag tag)                             (\(__ : Unit) ->
    result[XMLNode] (XMLElement tag (Nil[XMLNode]) (Nil[XMLNode])))))))))

and xmlElement : Parser[XMLNode] =
    bind[Char, XMLNode]             (char '<')                                  (\(__ : Char) ->
    bind[Unit, XMLNode]             xmlSpace                                    (\(__ : Unit) ->
    bind[PString, XMLNode]          xmlKey                                      (\(tag : PString) ->
    bind[Unit, XMLNode]             xmlSpace                                    (\(__ : Unit) ->
    bind[PList[XMLNode], XMLNode]   (sepby[XMLNode, Unit] xmlAttr xmlSpace)     (\(attrs: PList[XMLNode]) ->
    bind[Unit, XMLNode]             xmlSpace                                    (\(__ : Unit) ->
    bind[Char, XMLNode]             (char '>')                                  (\(__ : Char) ->
    bind[PList[XMLNode], XMLNode]   (many1[XMLNode] xmlNode)                    (\(ch : PList[XMLNode]) ->
    bind[Unit, XMLNode]             xmlSpace                                    (\(__ : Unit) ->
    bind[Unit, XMLNode]             (xmlEndTag tag)                             (\(__ : Unit) ->
    result[XMLNode] (XMLElement tag attrs ch)))))))))))

and xmlNode : Parser[XMLNode] =
    choice[XMLNode] xmlText xmlElement;


-- Test helper functions

let error (msg : String) = {
    java.lang.System.err.println(msg);
    java.lang.System.exit(1);
    ()
};

let assert (b : Bool) =
    if b then
        ()
    else
        error "assert failed!";

let rec listEqual [A] (a : PList[A]) (b : PList[A]) : Bool =
    case a of
        Nil         -> { case b of Nil -> True | Cons x xs -> False }
     |  Cons x xs   -> case b of
                            Nil          -> False
                         |  Cons xb xsb  ->
                                if x == xb then
                                    listEqual[A] (eval[PList[A]] xs) (eval[PList[A]] xsb)
                                else False;

let rec parseListEqual [A] (a : PList[(A, PString)]) (b : PList[(A, PString)]) : Bool =
    case a of
        Nil         -> { case b of Nil -> True | Cons x xs -> False }
     |  Cons x xs   -> case b of
                            Nil          -> False
                         |  Cons xb xsb  -> if x._1 == xb._1 && (listEqual[Char] x._2 xb._2) then
                                                parseListEqual[A] (eval[PList[(A, PString)]] xs)
                                                                  (eval[PList[(A, PString)]] xsb)
                                            else False;

let rec parseStringEqual (a : PList[(PString, PString)]) (b : PList[(PString, PString)]) : Bool =
    case a of
        Nil         -> { case b of Nil -> True | Cons x xs -> False }
     |  Cons x xs   -> case b of
                            Nil          -> False
                         |  Cons xb xsb  ->
                                if (listEqual[Char] x._1 xb._1) && (listEqual[Char] x._2 xb._2) then
                                    (parseStringEqual (eval[PList[(PString, PString)]] xs)
                                                      (eval[PList[(PString, PString)]] xsb))
                                else False;

let rec polyStringResultToString (r : PList[(PString, PString)]) : String =
    listToString[(PString, PString)] r
        (\(x : (PString, PString)) -> "(".concat(toString x._1).concat(", \"").concat(toString x._2).concat("\")"));

let rec charResultToString (r : PList[(Char, PString)]) : String =
    listToString[(Char, PString)] r
        (\(x : (Char, PString)) -> "(".concat(x._1.toString()).concat(", \"").concat(toString x._2).concat("\")"));

let rec intResultToString (r : PList[(Int, PString)]) : String =
    listToString[(Int, PString)] r
        (\(x : (Int, PString)) -> "(".concat(x._1.toString()).concat(", \"").concat(toString x._2).concat("\")"));

let rec xmlNodeToString (xml : XMLNode) : String =
    case xml of
        XMLText str         -> "XMLText ".concat(toString str)
     |  XMLComment str      -> "XMLComment ".concat(toString str)
     |  XMLAttr attr        -> "XMLAttr (".concat(toString attr._1).concat(", ").concat(toString attr._2).concat(")")
     |  XMLCData cdata      -> "XMLCData ".concat(toString cdata)
     |  XMLElement tag attrs children
            -> "XMLElement ".concat(toString tag)
                            .concat(" ")
                            .concat(listToString[XMLNode] attrs xmlNodeToString)
                            .concat(" ")
                            .concat(listToString[XMLNode] children xmlNodeToString);

let println (s : String) = java.lang.System.out.println(s);
let print (s : String) = java.lang.System.out.print(s);

let printStringResult (r : PList[(PString, PString)]) =
    print (polyStringResultToString r);

let printCharResult (r : PList[(Char, PString)]) =
    print (charResultToString r);

let printIntResult (r : PList[(Int, PString)]) =
    print (intResultToString r);

let printFirstIntResult (r : PList[(Int, PString)]) =
    case first[(Int, PString)] r of
        Nothing        -> print "Nothing in the List!!!"
     |  Just x        -> print "(".concat(x._1.toString()).concat(", \"").concat(toString x._2).concat("\")");
let printFirstCharResult (r : PList[(Char, PString)]) =
    case first[(Char, PString)] r of
        Nothing        -> print "Nothing in the List!!!"
     |  Just x        -> print "(".concat(x._1.toString()).concat(", \"").concat(toString x._2).concat("\")");
let printFirstStringResult (r : PList[(PString, PString)]) =
    case first[(PString, PString)] r of
        Nothing        -> print "Nothing in the List!!!"
     |  Just x        -> print "(".concat(toString x._1).concat(", \"").concat(toString x._2).concat("\")");
let printFirstXMLResult (r : PList[(XMLNode, PString)]) =
    case first[(XMLNode, PString)] r of
        Nothing        -> print "Nothing in the List!!"
     |  Just x         -> print "(".concat(xmlNodeToString x._1).concat(", \"").concat(toString x._2).concat("\")");

{
    println "------- Test Utilities -------";

    print "testing listEqual: ";
    assert (listEqual[Int] (singleton[Int] 1) (singleton[Int] 1));
    println "\t...ok";

    print "testing map: ";
    assert (listEqual[Char] (map[Char,Char] (\(c : Char) -> 'm') (fromString "hello")) (fromString "mmmmm"));
    println "\t...ok";

    print "testing foldr: ";
    let testlist = (take[Int] 5 (nats 1));
    assert ((foldr[Int,Int] (\(a : Int) (b : Int) -> a + b) 0 testlist) == 15);
    println "\t...ok";

    print "testing foldl: ";
    let testlist = (take[Int] 5 (nats 1));
    assert ((foldl[Int,Int] (\(b : Int) (a : Int) -> a + b) 0 testlist) == 15);
    println "\t...ok";

    println "\n------- Test Combinators -------";

    print "testing char 'a' (fromString \"abcd\"): ";
    assert (parseListEqual[Char]
                          (char 'a' (fromString "abcd"))
                          (singleton[(Char, PString)] ('a', (fromString "bcd"))));
    println "\t...ok";

    print "testing upper (fromString \"ABC\"): ";
    assert (parseListEqual[Char]
                          (upper (fromString "ABC"))
                          (singleton[(Char, PString)] ('A', (fromString "BC"))));
    println "\t...ok";

    print "testing letter (fromString \"abcd\"): ";
    printCharResult (letter (fromString "abcd"));
    assert (parseListEqual[Char] (letter (fromString "abcd")) (singleton[(Char, PString)] ('a', (fromString "bcd"))));
    println "\t...ok";

    print "testing string (fromString \"abc\") (fromString \"abcd\"): ";
    assert (parseStringEqual (string (fromString "abc") (fromString "abcd"))
                             (singleton[(PString, PString)] ((fromString "abc"), (fromString "d"))));
    println "\t...ok";

    print "testing many (char 'a') (fromString \"aaab\"): ";
    -- Should be [("", "aaab"), ("a", "aab"), ("aa", "ab"), ("aaa", "b")]
    printStringResult (many[Char] (char 'a') (fromString "aaab"));
    println "\t...ok";

    print "testing many1 (char 'a') (fromString \"aaab\"): ";
    -- Should be [("a", "aab"), ("aa", "ab"), ("aaa", "b")]
    printStringResult (many1[Char] (char 'a') (fromString "aaab"));
    println "\t...ok";

    print "testing choice (char 'a') (char 'b') (fromString \"aaab\"): ";
    assert (parseListEqual[Char] (choice[Char] (char 'a') (char 'b') (fromString "aaab"))
                                 (singleton[(Char, PString)] ('a', fromString "aab")));
    println "\t...ok";

    println "testing choice (string \"aa\") (string \"aaa\") (fromString \"aaab\"): ";
    printStringResult (choice[PString] (string (fromString "aa")) (string (fromString "aaa")) (fromString "aaab"));
    assert (parseStringEqual (choice[PString] (string (fromString "aa")) (string (fromString "aaa")) (fromString "aaab"))
           (concat2[(PString, PString)] (singleton[(PString, PString)] (fromString "aa", fromString "ab"))
                                        (singleton[(PString, PString)] (fromString "aaa", fromString "b"))));
    println "\t...ok";

    println "testing word (fromString \"aaabcd abcd\"): ";
    printStringResult (word (fromString "aaabcd abcd"));
    println "\t...ok";

    println "testing natural (fromString \"12345\"): ";
    printIntResult (natural (fromString "12345"));
    println "\t...ok";

    println "testing sepby1[PString, Char] word (char ',') (fromString \"abc,def\"): ";
    assert (len[(PList[PString], PString)] (sepby1[PString, Char] (word) (char ',') (fromString "abc,def")) == 6);
    println "\t...ok";

    println "testing noneof (fromString \"abc\") (fromString \"dce\"): ";
    printFirstCharResult (noneof (fromString "abc") (fromString "dce"));
    println "\t...ok";


    println "\n---------- Test Simple Arithmetic Expression Parser ------------";

    println "testing expr (fromString \"123\"): ";
    printFirstIntResult (expr (fromString "123"));
    println "\t...ok";

    println "testing expr (fromString \"(123)\"): ";
    printFirstIntResult (expr (fromString "(123)"));
    println "\t...ok";

    println "testing expr (fromString \"1+2\"): ";
    printFirstIntResult (expr (fromString "1+2"));
    println "\t...ok";

    println "testing expr (fromString \"10+2\"): ";
    printFirstIntResult (expr (fromString "10+2"));
    println "\t...ok";

    println "testing expr (fromString \"(10+2)*2\"): ";
    printFirstIntResult (expr (fromString "(10+2)*2"));
    println "\t...ok";

    println "testing expr (fromString \"(10+2)*2/6\"): ";
    printFirstIntResult (expr (fromString "(10+2)*2/6"));
    println "\t...ok";


    println "\n ---------- Test Naive XML Parser ------------";

    println "testing xmlComment (fromString \"<!-- hahaa? -->\"): ";
    printFirstStringResult (xmlComment (fromString "<!-- hahaa? -->"));
    println "\t...ok";

    println "testing xmlDoubleQuotedString (fromString \"\\\"abcdef\\\"\"): ";
    printFirstStringResult (xmlDoubleQuotedString (fromString "\"abcdef\""));
    println "\t...ok";

    println "testing xmlSingleQuotedString (fromString \"'abcdef'\"): ";
    printFirstStringResult (xmlSingleQuotedString (fromString "'abcdef'"));
    println "\t...ok";

    println "testing xmlSingleQuotedString (fromString \"'abcdef'\"): ";
    printFirstStringResult (xmlSingleQuotedString (fromString "'abcdef'"));
    println "\t...ok";

    println "testing xmlText (fromString \"abcdefg&lt;hijk\"): ";
    printFirstXMLResult (xmlText (fromString "abcdefg&lt;hijk"));
    println "\t...ok";

    println "testing xmlAttr (fromString \"key = \"vvvalue\"\"): ";
    printFirstXMLResult (xmlAttr (fromString "key = \"vvvalue\""));
    println "\t...ok";

    println "testing xmlSimpleElement (fromString \"<a></a>\"): ";
    printFirstXMLResult (xmlSimpleElement (fromString "<a></a>"));
    println "\t..ok";

    -- FIXME: Stack Overflow
    --println "testing xmlElement (fromString \"<a></a>\"): ";
    --printFirstXMLResult (xmlElement (fromString "<a></a>"));
    --println "\t...ok";

    "\n-- END --"
}
