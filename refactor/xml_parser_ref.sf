{-#
    INCLUDE "plist.sf"
    INCLUDE "pstring.sf"
    INCLUDE "parser_ref.sf"
#-}

-- Naive XML Parser

data XMLNode = XMLText      String
             | XMLAttr      String String
             | XMLElement   String PList[XMLNode] PList[XMLNode]
             | XMLCData     String
             | XMLComment   String
             | XMLProcInst  String PList[XMLNode]
             ;

let rec xmlNodeEqual (a : XMLNode) (b : XMLNode) : Bool =
    case a of
        XMLText stra            -> {
            case b of
                XMLText strb                    -> stringEq stra strb
             |  XMLComment str                  -> False
             |  XMLAttr key val                 -> False
             |  XMLCData cdata                  -> False
             |  XMLProcInst t attrs             -> False
             |  XMLElement tag attrs children   -> False
        }
     |  XMLComment stra         -> {
            case b of
                XMLText strb                    -> False
             |  XMLComment strb                 -> stringEq stra strb
             |  XMLAttr key val                 -> False
             |  XMLCData cdata                  -> False
             |  XMLProcInst t attrs             -> False
             |  XMLElement tag attrs children   -> False
        }
     |  XMLAttr keya vala       -> {
            case b of
                XMLText strb                    -> False
             |  XMLComment strb                 -> False
             |  XMLAttr keyb valb               -> (stringEq keya keyb) && (stringEq vala valb)
             |  XMLCData cdata                  -> False
             |  XMLProcInst t attrs             -> False
             |  XMLElement tag attrs children   -> False
        }
     |  XMLCData cdataa         -> {
            case b of
                XMLText strb                    -> False
             |  XMLComment strb                 -> False
             |  XMLAttr key val                 -> False
             |  XMLCData cdatab                 -> stringEq cdataa cdatab
             |  XMLProcInst t attrs             -> False
             |  XMLElement tag attrs children   -> False
        }
     |  XMLProcInst ta attrsa   -> {
            case b of
                XMLText strb                    -> False
             |  XMLComment strb                 -> False
             |  XMLAttr key val                 -> False
             |  XMLCData cdatab                 -> False
             |  XMLProcInst tb attrsb           ->
                    ((stringEq ta tb) && (pListEq[XMLNode] xmlNodeEqual attrsa attrsb))
             |  XMLElement tag attrs children   -> False
        }
     |  XMLElement taga attrsa childrena    -> {
            case b of
                XMLText strb                        -> False
             |  XMLComment str                      -> False
             |  XMLAttr key val                     -> False
             |  XMLCData cdata                      -> False
             |  XMLProcInst t attrs                 -> False
             |  XMLElement tagb attrsb childrenb    ->
                    (stringEq taga tagb)
                        && (pListEq[XMLNode] xmlNodeEqual attrsa attrsb)
                        && (pListEq[XMLNode] xmlNodeEqual childrena childrenb)
        };

let rec xmlNodeToString (xml : XMLNode) : String =
    case xml of
        XMLText str         -> "XMLText \{str}"
     |  XMLComment str      -> "XMLComment \{str}"
     |  XMLAttr key val     -> "XMLAttr \{key} \{val}"
     |  XMLCData cdata      -> "XMLCData \{cdata}"
     |  XMLProcInst t attrs
            -> "XMLProcInst \{t} \{pListToString[XMLNode] xmlNodeToString attrs}"
     |  XMLElement tag attrs children
            -> "XMLElement \{tag} \{pListToString[XMLNode] xmlNodeToString attrs} \{pListToString[XMLNode] xmlNodeToString children}";

--let xmlComment : Parser[PList[Char]] =
--    bind[LPString, PList[Char]]     (string (pStringFromString "<!--")) (\(cstart : LPString) ->
--    bind[PList[Char], PList[Char]] (many[Char] item) (\(comment : PList[Char]) ->
--    bind[LPString, PList[Char]]     (string (pStringFromString "-->")) (\(cend : LPString) ->
--    result[PList[Char]] comment)));

let xmlComment : Parser[XMLNode] =
    (string "<!--")
        *>[LPString, LPList[Char]] (many[Char] item)
        <*[LPList[Char], LPString] (string "-->")
        <$>[LPList[Char], XMLNode] (\(cmt : LPList[Char]) -> XMLComment (lPStringToString cmt));

--let xmlSpace : Parser[Unit] =
--    only[Unit]
--        (bind[PList[Char], Unit] (many[Char] whitespace) (\(sp1 : PList[Char]) ->
--         bind[PList[Char], Unit] xmlComment              (\(cmt : PList[Char]) ->
--         bind[PList[Char], Unit] (many[Char] whitespace) (\(sp2 : PList[Char]) ->
--         result[Unit] ()))));
let xmlSpace : Parser[Unit] =
    only[Unit]
        (choice[Unit]
            (bind[LPList[Char], Unit] (many[Char] whitespace) (\(__ : LPList[Char]) -> result[Unit] ()))
            (bind[LPList[Char], Unit] (many[Char] whitespace) (\(sp1 : LPList[Char]) ->
             bind[XMLNode, Unit]     xmlComment              (\(cmt : XMLNode) ->
             bind[LPList[Char], Unit] (many[Char] whitespace) (\(sp2 : LPList[Char]) ->
             result[Unit] ())))));

-- Normal version
let xmlEscapedChar : Parser[Char] =
    let quot = (string "&quot;") $>[LPString, Char] '"';
    let apos = (string "&apos;") $>[LPString, Char] '\'';
    let lt = (string "&lt;")     $>[LPString, Char] '<';
    let gt = (string "&gt;")     $>[LPString, Char] '>';
    let amp = (string "&amp;")   $>[LPString, Char] '&';

    quot `choice[Char]` apos `choice[Char]` lt `choice[Char]` gt `choice[Char]` amp;

let xmlEscapedCodePoint : Parser[LPString] =
    (string "&#x")
        *>[LPString, Int] hexdecimal
        <*[Int, Char] (char ';')
        <$>[Int, LPString] (\(codep : Int) ->
                (lPStringFromString (new java.lang.String(java.lang.Character.toChars(codep)))));

let xmlChar : Parser[Char] =
    xmlEscapedChar <|>[Char] (noneof "\"'<>&");

let xmlString : Parser[LPString] =
    many1[Char] xmlChar
       <|>[LPString] xmlEscapedCodePoint;

let xmlDoubleQuotedString : Parser[LPString] =
    (char '"') *>[Char, LPString] xmlString <*[LPString, Char] (char '"');

let xmlSingleQuotedString : Parser[LPString] =
    (char '\'') *>[Char, LPString] xmlString <*[LPString, Char] (char '\'');

let xmlQuotedString : Parser[LPString] =
    choice[LPString] xmlDoubleQuotedString xmlSingleQuotedString;

let xmlText : Parser[XMLNode] =
    xmlString <$>[LPString, XMLNode] (\(content : LPString) -> XMLText (lPStringToString content));

let xmlCData : Parser[XMLNode] =
    string "<![CDATA["
        *>[LPString, LPList[Char]] (many[Char] item)
            <$>[LPList[Char], XMLNode] (\(cd : LPList[Char]) -> XMLCData (lPStringToString cd))
        <*[XMLNode, LPString] (string "]]>");

let xmlKey : Parser[LPString] =
    many1[Char] (letter <|>[Char] (char '-'));

let xmlAttr : Parser[XMLNode] =
    bind[LPString, XMLNode]  xmlKey                                                          (\(key : LPString) ->
    bind[LPString, XMLNode]  (xmlSpace >>[Unit, Char] (char '=')
                                         >>[Char, Unit] xmlSpace
                                         >>[Unit, LPString] xmlQuotedString)                 (\(val : LPString) ->
    result[XMLNode] (XMLAttr (lPStringToString key) (lPStringToString val))));

let xmlAttrs : Parser[PList[XMLNode]] =
    sepby[XMLNode, Unit] xmlAttr xmlSpace
        <$>[LPList[XMLNode], PList[XMLNode]] (lPListToPList[XMLNode]);

let xmlEndTag (tag : LPString) : Parser[Unit] =
    (string "</")
        >>[LPString, Unit]   xmlSpace
        >>[Unit, LPString]   (stringWithLPString tag)
        >>[LPString, Unit]   xmlSpace
        >>[Unit, Char]      (char '>')
        $>[Char, Unit]      ();

let rec xmlElement : Parser[XMLNode] =
    (char '<') >>[Char, Unit] xmlSpace >>[Unit, LPString] xmlKey >>=[LPString, XMLNode] (\(tag : LPString) ->
        xmlSpace >>[Unit, PList[XMLNode]] xmlAttrs >>=[PList[XMLNode], XMLNode] (\(attrs : PList[XMLNode]) ->
            -- Normal ends
            ((char '>') >>[Char, Unit] xmlSpace >>[Unit, PList[XMLNode]]
                xmlElementChildren <*[PList[XMLNode], Unit] xmlSpace <*[PList[XMLNode], Unit] (xmlEndTag tag)
                    <$>[PList[XMLNode], XMLNode] (\(ch : PList[XMLNode]) -> XMLElement (lPStringToString tag) attrs ch))

            <|>[XMLNode]

            -- Short ends
            ((string "/>")
                >>[LPString, XMLNode] (result[XMLNode] (XMLElement (lPStringToString tag) attrs (Nil[XMLNode]))))))

and xmlElementChildren : Parser[PList[XMLNode]] =
    (xmlCData <$>[XMLNode, PList[XMLNode]] (\(c : XMLNode) -> singleton[XMLNode] c)
        <|>[PList[XMLNode]] (xmlText `using[XMLNode, PList[XMLNode]]` (\(n : XMLNode) -> singleton[XMLNode] n))
        <|>[PList[XMLNode]] ((sepby1[XMLNode, Unit] xmlElement xmlSpace) <$>[LPList[XMLNode], PList[XMLNode]] (lPListToPList[XMLNode])))
    <|>[PList[XMLNode]] (result[PList[XMLNode]] (Nil[XMLNode]));

let xmlProcInst : Parser[XMLNode] =
    (string "<?") >>[LPString, Unit] xmlSpace
        >>[Unit, LPString] xmlKey >>=[LPString, XMLNode] (\(target : LPString) ->
            xmlSpace >>[Unit, PList[XMLNode]] xmlAttrs
                <*[PList[XMLNode], LPString] (xmlSpace >>[Unit, LPString] (string "?>"))
                    >>=[PList[XMLNode], XMLNode] (\(conts : PList[XMLNode]) ->
                        result[XMLNode] (XMLProcInst (lPStringToString target) conts)));

let parseXML : Parser[PList[XMLNode]] =
    (many[XMLNode] xmlProcInst)
        >>=[LPList[XMLNode], PList[XMLNode]] (\(procinst1 : LPList[XMLNode]) ->
            xmlElement >>=[XMLNode, PList[XMLNode]] (\(root : XMLNode) ->
                (many[XMLNode] xmlProcInst) >>=[LPList[XMLNode], PList[XMLNode]] (\(procinst2 : LPList[XMLNode]) ->
                    result[PList[XMLNode]] (lPListToPList[XMLNode] (procinst1 %++[XMLNode] (root %+>[XMLNode] procinst2))))));
