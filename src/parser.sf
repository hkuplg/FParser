
-- Definition of Thunk
type Thunk[A] = Unit -> A;

let invoke[A] (t : Thunk[A]) : A =
    t ();

-- Maybe definition

data Maybe[A] = Nothing
              | Just A
              ;

-- Result definition
data Result[S, E] = Ok S
                  | Err E
                  ;

-- Eq definition
type Eq[A] = A -> A -> Bool;

-- State definition
type State[S, A] = S -> (A, S);

-- ADT List
data PList[A] = Nil
              | Cons A (Thunk[PList[A]])
              ;

let rec nats (beg : Int) : PList[Int] =
    Cons[Int] beg (\(__ : Unit) -> nats (beg+1));

-- Utilities

let singleton[A] (x : A) : PList[A] =
    Cons[A] x (\(__: Unit) -> (Nil[A]));

let rec map[A, B] (f : A -> B) (l : PList[A]) : PList[B] =
    case l of
        Nil             ->      Nil[B]
     |  Cons x xs       ->      Cons[B] (f x) (\(__ : Unit) -> (map[A, B] f (invoke[PList[A]] xs)));

let rec foldl[A, B] (f : B -> A -> B) (z : B) (l : PList[A]) : B =
    case l of
        Nil             ->      z
     |  Cons x xs       ->      foldl[A, B] f (f z x) (invoke[PList[A]] xs);

--let rec foldr[A, B] (f : A -> B -> B) (z : B) (l : PList[A]) : B =
--    case l of
--        Nil             ->      z
--     |  Cons x xs       ->      f x (foldr[A, B] f z (invoke[PList[A]] xs));

let foldr[A, B] (f : A -> B -> B) (z : B) (l : PList[A]) : B =
    (let rec inner (s : PList[A]) (k : B -> B) : B =
        case s of
            Nil         -> k z
         |  Cons x xs   -> inner (invoke[PList[A]] xs) (\(y : B) -> k (f x y));
     inner l (\(x : B) -> x));


let join[A] (l : PList[A]) (j : A) : PList[A] = {
    let rec inner[A] (l : PList[A]) (j : A) : PList[A] =
        case l of
            Nil         -> (Nil[A])
         |  Cons x xs   -> (Cons[A] j (\(__ : Unit) ->
                                (Cons[A] x (\(__ : Unit) -> inner[A] (invoke[PList[A]] xs) j))));
    case l of
        Nil         -> (Nil[A])
     |  Cons x xs   -> (Cons[A] x (\(__ : Unit) -> inner[A] (invoke[PList[A]] xs) j))
};

let (+>)[A] (a : A) (l : PList[A]) : PList[A] =
    Cons[A] a (\(__ : Unit) -> l);

let rec concat2[A] (a : PList[A]) (b : PList[A]) : PList[A] =
    case a of
        Nil         ->  b
      | Cons x xs   ->  Cons[A] x (\(__ : Unit) -> (concat2[A] (invoke[PList[A]] xs) b));

let (@)[A] (a : PList[A]) (b : PList[A]) : PList[A] =
    concat2[A] a b;

let rec concat[A] (l : PList[PList[A]]) : PList[A] =
    case l of
        Nil         ->  Nil[A]
     |  Cons x xs   ->  concat2[A] x (concat[A] (invoke[PList[PList[A]]] xs));

let rec len[A] (l : PList[A]) : Int =
    case l of
        Nil         ->  0
     |  Cons _ xs   ->  1 + (len[A] (invoke[PList[A]] xs));

let isempty[A] (l : PList[A]) : Bool =
    case l of
        Nil         -> True
     |  Cons _ _    -> False;

let first[A] (l : PList[A]) : Maybe[A] =
    case l of
        Nil         -> Nothing[A]
     |  Cons x _    -> Just[A] x;

let rest[A] (l : PList[A]) : Maybe[PList[A]] =
    case l of
        Nil         -> Nothing[PList[A]]
     |  Cons _ xs   -> Just[PList[A]] (invoke[PList[A]] xs);

let rec take[A] (n : Int) (l : PList[A]) : PList[A] =
    if n <= 0 then
        (Nil[A])
    else
        case l of
            Nil         ->  Nil[A]
         |  Cons x xs   ->  Cons[A] x (\(__ : Unit) -> (take[A] (n-1) (invoke[PList[A]] xs)));

let listToString[A] (tostr : A -> String) (l : PList[A]) : String = {
    type StringBuilder = java.lang.StringBuilder;

    let inner = foldl[String, StringBuilder]
                    (\(b : StringBuilder) (a : String) -> b.append(a))
                    (new java.lang.StringBuilder("["))
                    (join[String] (map[A, String] tostr l) ", ");

    inner.append("]").toString()
};

let rec listEqual[A] (eq : Eq[A]) (a : PList[A]) (b : PList[A]) : Bool =
    case a of
        Nil         -> { case b of Nil -> True | Cons _ _ -> False }
     |  Cons ax axs ->
            case b of
                Nil         -> False
             |  Cons bx bxs -> if eq ax bx then
                                    listEqual[A] eq (invoke[PList[A]] axs) (invoke[PList[A]] bxs)
                               else False;

-- ADT String

type PString = PList[Char];

let toString (l : PString) : String =
    (foldl[Char, java.lang.StringBuilder]
        (\(b : java.lang.StringBuilder) (a : Char) -> b.append(a))
        (new java.lang.StringBuilder( ))
        l).toString();

let fromString (str : String) : PString = {
    let rec inner (str : String) (idx : Int) : PString =
        if idx == length(str) then
            (Nil[Char])
        else
            (Cons[Char] str.charAt(idx) (\(__ : Unit) -> (inner str (idx+1))));
    inner str 0
};

let rec stringEqual (a : PString) (b : PString) : Bool =
    listEqual[Char] (\(a : Char) (b : Char) -> a.equals(b)) a b;

let rec charin (c : Char) (str : PString) : Bool =
    case str of
        Nil         ->      False
     |  Cons x xs   ->      if x.equals(c) then True else (charin c (invoke[PString] xs));

-- Parser type definition

type Parser[A] = PString -> PList[(A, PString)];

let parseResultEqual[A] (eq : Eq[A]) (a : PList[(A, PString)]) (b : PList[(A, PString)]) : Bool =
    listEqual[(A, PString)]
        (\(a : (A, PString)) (b : (A, PString)) -> (eq a._1 b._1) && (stringEqual a._2 b._2))
        a b;

-- Primitive Parsers

let result[V] (value : V) : Parser[V] =
    \(inp : PString) -> singleton[(V, PString)] (value, inp);

let zero[V] : Parser[V] =
    \(inp : PString) -> Nil[(V, PString)];

let item : Parser[Char] =
    \(inp : PString) ->
        case inp of
            Nil         ->      Nil[(Char, PString)]
          | Cons c xs   ->      singleton[(Char, PString)] (c, (invoke[PString] xs));

-- Combinators

let bind[A, B] (p : Parser[A]) (f : A -> Parser[B]) : Parser[B] =
    \(inp : PString) ->
        concat[(B, PString)]
              (map[(A, PString), PList[(B, PString)]]
                  (\(v : (A, PString)) -> f v._1 v._2) (p inp));

let (>>=)[A, B] (p : Parser[A]) (f : A -> Parser[B]) : Parser[B] =
    bind[A, B] p f;

let (>>)[A, B] (p : Parser[A]) (q : Parser[B]) : Parser[B] =
    p >>=[A, B] (\(__ : A) -> q);

let (<*)[A, B] (p : Parser[A]) (q : Parser[B]) : Parser[A] =
    p >>=[A, A] (\(a : A) ->
    q >>=[B, A] (\(__ : B) ->
    result[A] a));

let (*>)[A, B] (p : Parser[A]) (q : Parser[B]) : Parser[B] =
    p >>[A, B] q;

let using[A, B] (p : Parser[A]) (f : A -> B) : Parser[B] =
    bind[A, B] p (\(a : A) -> result[B] (f a));

let (<$>)[A, B] (p : Parser[A]) (f : A -> B) : Parser[B] =
    using[A, B] p f;

let ($>)[A, B] (p : Parser[A]) (b : B) : Parser[B] =
    using[A, B] p (\(__ : A) -> b);

let seq[A, B] (p : Parser[A]) (q : Parser[B]) : Parser[(A, B)] =
    bind[A, (A, B)] p (\(x : A) ->
    bind[B, (A, B)] q (\(y : B) ->
    result[(A, B)] (x, y)));

let choice[A] (p : Parser[A]) (q : Parser[A]) : Parser[A] =
    \(inp : PString) ->
        (p inp) @[(A, PString)] (q inp);

let (<|>)[A] (p : Parser[A]) (q : Parser[A]) : Parser[A] =
    choice[A] p q;

let sat (f : Char -> Bool) : Parser[Char] =
    bind[Char, Char] item (\(x : Char) -> if f x then (result[Char] x) else zero[Char]);

let char (x : Char) : Parser[Char] =
    sat (\(y : Char) -> x == y);

let notchar (x : Char) : Parser[Char] =
    sat (\(y : Char) -> x != y);

let digit : Parser[Char] =
    sat (\(x : Char) -> java.lang.Character.isDigit(x));

let upper : Parser[Char] =
    sat (\(x : Char) -> java.lang.Character.isUpperCase(x));

let lower : Parser[Char] =
    sat (\(x : Char) -> java.lang.Character.isLowerCase(x));

let space : Parser[Char] =
    sat (\(x : Char) -> java.lang.Character.isSpaceChar(x));

let whitespace : Parser[Char] =
    sat (\(x : Char) -> java.lang.Character.isWhitespace(x));

let letter : Parser[Char] =
    choice[Char] lower upper;

let alphanum : Parser[Char] =
    choice[Char] letter digit;

let noneof (s : PString) : Parser[Char] =
    sat (\(x : Char) -> (charin x s) == False);

let oneof (s : PString) : Parser[Char] =
    sat (\(x : Char) -> charin x s);

let rec string (s : PString) : Parser[PString] =
    case s of
        Nil         ->  result (Nil[Char])
     |  Cons x xs   ->
            (let xs = invoke[PString] xs;
             bind[Char, PString]    (char x)    (\(dummy1 : Char) ->
             bind[PString, PString] (string xs) (\(dummy2 : PString) ->
             result[PString] (Cons[Char] x (\(__ : Unit) -> xs)))));

-- Repetition

let rec many[A] (p : Parser[A]) : Parser[PList[A]] =
    choice[PList[A]] (bind[A, PList[A]] p (\(x : A) ->
                      bind[PList[A], PList[A]] (many[A] p) (\(xs : PList[A]) ->
                      result[PList[A]] (Cons[A] x (\(__ : Unit) -> xs)))))
                     (result[PList[A]] (Nil[A]));

let many1[A] (p : Parser[A]) : Parser[PList[A]] =
    bind[A, PList[A]] p (\(x : A) ->
    bind[PList[A], PList[A]] (many[A] p) (\(xs : PList[A]) ->
    result[PList[A]] (Cons[A] x (\(__ : Unit) -> xs))));

let word : Parser[PString] =
    many1[Char] letter;

let ident : Parser[PString] =
    bind[Char, PString] lower (\(x : Char) ->
    bind[PString, PString] (many[Char] alphanum) (\(xs : PString) ->
    result[PString] (Cons[Char] x (\(__ : Unit) -> xs))));

let natural : Parser[Int] = {
    let eval (xs : PList[Char]) =
        foldl[Int, Int] (\(b : Int) (a : Int) -> 10 * b + a)
                        0
                        (map[Char, Int] (\(c : Char) -> java.lang.Character.digit(c, 10)) xs);

    bind[PList[Char], Int] (many1[Char] digit) (\(xs : PList[Char]) -> result[Int] (eval xs))
};

let hexdecimal : Parser[Int] = {
    let eval (xs : PList[Char]) =
        foldl[Int, Int] (\(b : Int) (a : Int) -> 16 * b + a)
                        0
                        (map[Char, Int] (\(c : Char) -> java.lang.Character.digit(c, 16)) xs);
    (many1[Char] (oneof (fromString "1234567890abcdefABCDEF")))
        <$>[PList[Char], Int] (\(xs : PList[Char]) -> eval xs)
};

let int : Parser[Int] =
    choice[Int] ((char '-') >>[Char, Int]
                 (using[Int,Int] natural (\(n : Int) -> (-n))))
              natural;

-- Repetition with seperators

let sepby1[A, B] (p : Parser[A]) (sep : Parser[B]) : Parser[PList[A]] = {
    let rep[A, B] (p : Parser[A]) : Parser[A] =
        bind[B, A] sep (\(s : B) -> bind[A, A] p (\(y : A) -> result[A] y));
    bind[A, PList[A]] p (\(x : A) ->
    bind[PList[A], PList[A]] (many[A] (rep[A, B] p)) (\(xs : PList[A]) ->
    result[PList[A]] (Cons[A] x (\(__ : Unit) -> xs))))
};

let sepby[A, B] (p : Parser[A]) (sep : Parser[B]) : Parser[PList[A]] =
    choice[PList[A]] (sepby1[A, B] p sep) (result[PList[A]] (Nil[A]));


-- More complicated

-- Parses non-empty sequences of items seperated by operators that associate to the left
let chainl1[A] (p : Parser[A]) (op : Parser[A -> A -> A]) : Parser[A] = {
    let fy =
        bind[A -> A -> A, (A -> A -> A, A)] op (\(f : A -> A -> A) ->
        bind[A, (A -> A -> A, A)]           p  (\(y : A) ->
        result[(A -> A -> A, A)] (f, y)));

    bind[A, A]                           p                            (\(x : A) ->
    bind[PList[(A -> A -> A, A)], A]     (many[(A -> A -> A, A)] fy)  (\(fys: PList[(A -> A -> A, A)]) ->
    result[A] (foldl[(A -> A -> A, A), A] (\(x : A) (fy : (A -> A -> A, A)) -> fy._1 x fy._2) x fys)))
};

-- associate to the right
let rec chainr1[A] (p : Parser[A]) (op : Parser[A -> A -> A]) : Parser[A] =
    bind[A, A] p (\(x : A) ->
        choice[A] (bind[A -> A -> A, A] op (\(f : A -> A -> A) ->
                 bind[A, A] (chainr1[A] p op) (\(y : A) -> -- Calculate the result on the right
                 result[A] (f x y))))
                (result[A] x));

let chainl[A] (p : Parser[A]) (op : Parser[A -> A -> A]) (v : A) : Parser[A] =
    choice[A] (chainl1[A] p op) (result[A] v);

let chainr[A] (p : Parser[A]) (op : Parser[A -> A -> A]) (v : A) : Parser[A] =
    choice[A] (chainr1[A] p op) (result[A] v);


-- Improved Laziness (Haven't supported in F2J yet)

-- Pick the first (if exists) result
--let only[A] (p : Parser[A]) : Parser[A] =
--    \(inp : PString) ->
--        case (p inp) of
--            Nil         -> (Nil[(A, PString)])
--         |  Cons x xs   -> (singleton[(A, PString)] x);

let only[A] (p : Parser[A]) : Parser[A] =
    \(inp : PString) -> take[(A, PString)] 1 (p inp);

-- Lazy choice
let lazychoice[A] (p : Parser[A]) (q : Parser[A]) : Parser[A] =
    only[A] (choice[A] p q);

-- Simple arithmetic expression

let bracket[A, B, C] (open : Parser[A]) (p : Parser[B]) (close : Parser[C]) : Parser[B] =
    open *>[A, B] p <*[B, C] close;

let operation = {
    let addop (a : Int) (b : Int) : Int = a + b;
    let subop (a : Int) (b : Int) : Int = a - b;
    let mulop (a : Int) (b : Int) : Int = a * b;
    let divop (a : Int) (b : Int) : Int = a / b;

    let add = (char '+') $>[Char, Int -> Int -> Int] addop;
    let sub = (char '-') $>[Char, Int -> Int -> Int] subop;
    let mul = (char '*') $>[Char, Int -> Int -> Int] mulop;
    let div = (char '/') $>[Char, Int -> Int -> Int] divop;

    add `choice[Int -> Int -> Int]` sub `choice[Int -> Int -> Int]` mul `choice[Int -> Int -> Int]` div
};

let rec expr : Parser[Int] =
    \(s : PString) -> chainl1[Int] factor operation s
and factor : Parser[Int] =
    \(s : PString) -> choice[Int] natural (bracket[Char, Int, Char] (char '(') expr (char ')')) s;

-- Naive XML Parser

data XMLNode = XMLText      PString
             | XMLAttr      PString PString
             | XMLElement   PString PList[XMLNode] PList[XMLNode]
             | XMLCData     PString
             | XMLComment   PString
             | XMLProcInst  PString PList[XMLNode]
             ;

let rec xmlNodeEqual (a : XMLNode) (b : XMLNode) : Bool =
    case a of
        XMLText stra            -> {
            case b of
                XMLText strb                    -> stringEqual stra strb
             |  XMLComment str                  -> False
             |  XMLAttr key val                 -> False
             |  XMLCData cdata                  -> False
             |  XMLProcInst t attrs             -> False
             |  XMLElement tag attrs children   -> False
        }
     |  XMLComment stra         -> {
            case b of
                XMLText strb                    -> False
             |  XMLComment strb                 -> stringEqual stra strb
             |  XMLAttr key val                 -> False
             |  XMLCData cdata                  -> False
             |  XMLProcInst t attrs             -> False
             |  XMLElement tag attrs children   -> False
        }
     |  XMLAttr keya vala       -> {
            case b of
                XMLText strb                    -> False
             |  XMLComment strb                 -> False
             |  XMLAttr keyb valb               -> (stringEqual keya keyb) && (stringEqual vala valb)
             |  XMLCData cdata                  -> False
             |  XMLProcInst t attrs             -> False
             |  XMLElement tag attrs children   -> False
        }
     |  XMLCData cdataa         -> {
            case b of
                XMLText strb                    -> False
             |  XMLComment strb                 -> False
             |  XMLAttr key val                 -> False
             |  XMLCData cdatab                 -> stringEqual cdataa cdatab
             |  XMLProcInst t attrs             -> False
             |  XMLElement tag attrs children   -> False
        }
     |  XMLProcInst ta attrsa   -> {
            case b of
                XMLText strb                    -> False
             |  XMLComment strb                 -> False
             |  XMLAttr key val                 -> False
             |  XMLCData cdatab                 -> False
             |  XMLProcInst tb attrsb           ->
                    ((stringEqual ta tb) && (listEqual[XMLNode] xmlNodeEqual attrsa attrsb))
             |  XMLElement tag attrs children   -> False
        }
     |  XMLElement taga attrsa childrena    -> {
            case b of
                XMLText strb                        -> False
             |  XMLComment str                      -> False
             |  XMLAttr key val                     -> False
             |  XMLCData cdata                      -> False
             |  XMLProcInst t attrs                 -> False
             |  XMLElement tagb attrsb childrenb    ->
                    (stringEqual taga tagb)
                        && (listEqual[XMLNode] xmlNodeEqual attrsa attrsb)
                        && (listEqual[XMLNode] xmlNodeEqual childrena childrenb)
        };

let rec xmlNodeToString (xml : XMLNode) : String =
    case xml of
        XMLText str         -> "XMLText ".concat(toString str)
     |  XMLComment str      -> "XMLComment ".concat(toString str)
     |  XMLAttr key val     -> "XMLAttr ".concat(toString key).concat(" ").concat(toString val)
     |  XMLCData cdata      -> "XMLCData ".concat(toString cdata)
     |  XMLProcInst t attrs
            -> "XMLProcInst ".concat(toString t)
                             .concat(" ")
                             .concat(listToString[XMLNode] xmlNodeToString attrs)
     |  XMLElement tag attrs children
            -> "XMLElement ".concat(toString tag)
                            .concat(" ")
                            .concat(listToString[XMLNode] xmlNodeToString attrs)
                            .concat(" ")
                            .concat(listToString[XMLNode] xmlNodeToString children);

--let xmlComment : Parser[PList[Char]] =
--    bind[PString, PList[Char]]     (string (fromString "<!--")) (\(cstart : PString) ->
--    bind[PList[Char], PList[Char]] (many[Char] item) (\(comment : PList[Char]) ->
--    bind[PString, PList[Char]]     (string (fromString "-->")) (\(cend : PString) ->
--    result[PList[Char]] comment)));

let xmlComment : Parser[XMLNode] =
    (string (fromString "<!--"))
        *>[PString, PList[Char]] (many[Char] item)
        <*[PList[Char], PString] (string (fromString "-->"))
        <$>[PList[Char], XMLNode] (\(cmt : PList[Char]) -> XMLComment cmt);

--let xmlSpace : Parser[Unit] =
--    only[Unit]
--        (bind[PList[Char], Unit] (many[Char] whitespace) (\(sp1 : PList[Char]) ->
--         bind[PList[Char], Unit] xmlComment              (\(cmt : PList[Char]) ->
--         bind[PList[Char], Unit] (many[Char] whitespace) (\(sp2 : PList[Char]) ->
--         result[Unit] ()))));
let xmlSpace : Parser[Unit] =
    only[Unit]
        (choice[Unit]
            (bind[PList[Char], Unit] (many[Char] whitespace) (\(__ : PList[Char]) -> result[Unit] ()))
            (bind[PList[Char], Unit] (many[Char] whitespace) (\(sp1 : PList[Char]) ->
             bind[XMLNode, Unit]     xmlComment              (\(cmt : XMLNode) ->
             bind[PList[Char], Unit] (many[Char] whitespace) (\(sp2 : PList[Char]) ->
             result[Unit] ())))));

-- Normal version
let xmlEscapedChar : Parser[Char] = {
    let quot = (string (fromString "&quot;")) $>[PString, Char] '"';
    let apos = (string (fromString "&apos;")) $>[PString, Char] '\'';
    let lt = (string (fromString "&lt;"))     $>[PString, Char] '<';
    let gt = (string (fromString "&gt;"))     $>[PString, Char] '>';
    let amp = (string (fromString "&amp;"))   $>[PString, Char] '&';

    quot `choice[Char]` apos `choice[Char]` lt `choice[Char]` gt `choice[Char]` amp
};

-- FIXME: Issue125
let xmlEscapedCodePoint : Parser[PString] =
    (string (fromString "&#x"))
        *>[PString, Int] hexdecimal
        <*[Int, Char] (char ';')
--        <$>[Int, PString] (\(codep : Int) -> (fromString (new java.lang.String(java.lang.Character.toChars(codep)))));
        <$>[Int, PString] (\(codep : Int) -> (fromString (new java.lang.String( ))));

let xmlChar : Parser[Char] =
    xmlEscapedChar <|>[Char] (noneof (fromString "\"'<>&"));

let xmlString : Parser[PString] =
    many1[Char] xmlChar;
--        <|>[PString] xmlEscapedCodePoint;

let xmlDoubleQuotedString : Parser[PString] =
    (char '"') *>[Char, PString] xmlString <*[PString, Char] (char '"');

let xmlSingleQuotedString : Parser[PString] =
    (char '\'') *>[Char, PString] xmlString <*[PString, Char] (char '\'');

let xmlQuotedString : Parser[PString] =
    choice[PString] xmlDoubleQuotedString xmlSingleQuotedString;

let xmlText : Parser[XMLNode] =
    xmlString <$>[PString, XMLNode] (\(content : PString) -> XMLText content);

let xmlCData : Parser[XMLNode] =
    string (fromString "<![CDATA[")
        *>[PString, PList[Char]] (many[Char] item)
            <$>[PList[Char], XMLNode] (\(cd : PList[Char]) -> XMLCData cd)
        <*[XMLNode, PString] (string (fromString "]]>"));

let xmlKey : Parser[PString] =
    many1[Char] (letter <|>[Char] (char '-'));

let xmlAttr : Parser[XMLNode] =
    bind[PString, XMLNode]  xmlKey                                                          (\(key : PString) ->
    bind[PString, XMLNode]  (xmlSpace >>[Unit, Char] (char '=')
                                      >>[Char, Unit] xmlSpace
                                      >>[Unit, PString] xmlQuotedString)                    (\(val : PString) ->
    result[XMLNode] (XMLAttr key val)));

let xmlAttrs : Parser[PList[XMLNode]] =
    sepby[XMLNode, Unit] xmlAttr xmlSpace;

let xmlEndTag (tag : PString) : Parser[Unit] =
    (string (fromString "</"))
        >>[PString, Unit]   xmlSpace
        >>[Unit, PString]   (string tag)
        >>[PString, Unit]   xmlSpace
        >>[Unit, Char]      (char '>')
        $>[Char, Unit]      ();

--let rec xmlElement : Parser[XMLNode] =
--    bind[Char, XMLNode]             (char '<')                                  (\(__ : Char) ->
--    bind[Unit, XMLNode]             xmlSpace                                    (\(__ : Unit) ->
--    bind[PString, XMLNode]          xmlKey                                      (\(tag : PString) ->
--    bind[Unit, XMLNode]             xmlSpace                                    (\(__ : Unit) ->
--    bind[PList[XMLNode], XMLNode]   xmlAttrs                                    (\(attrs: PList[XMLNode]) ->
--    bind[Unit, XMLNode]             xmlSpace                                    (\(__ : Unit) ->
--        (bind[Char, XMLNode]             (char '>')                             (\(__ : Char) ->
--         bind[Unit, XMLNode]             xmlSpace                               (\(__ : Unit) ->
--         bind[PList[XMLNode], XMLNode]   xmlElementChildren                     (\(ch : PList[XMLNode]) ->
--         bind[Unit, XMLNode]             xmlSpace                               (\(__ : Unit) ->
--         bind[Unit, XMLNode]             (xmlEndTag tag)                        (\(__ : Unit) ->
--         result[XMLNode] (XMLElement tag attrs ch)))))))
--
--        `choice[XMLNode]` -- ^~~ normal style  v~~ shorter style
--
--        ((string (fromString "/>")) <$>[PString, XMLNode] (\(__ : PString) -> (XMLElement tag attrs (Nil[XMLNode]))))
--    ))))))

let rec xmlElement : Parser[XMLNode] =
    (char '<') >>[Char, Unit] xmlSpace >>[Unit, PString] xmlKey >>=[PString, XMLNode] (\(tag : PString) ->
        xmlSpace >>[Unit, PList[XMLNode]] xmlAttrs >>=[PList[XMLNode], XMLNode] (\(attrs : PList[XMLNode]) ->
            -- Normal ends
            ((char '>') >>[Char, Unit] xmlSpace >>[Unit, PList[XMLNode]]
                xmlElementChildren <*[PList[XMLNode], Unit] xmlSpace <*[PList[XMLNode], Unit] (xmlEndTag tag)
                    <$>[PList[XMLNode], XMLNode] (\(ch : PList[XMLNode]) -> XMLElement tag attrs ch))

            <|>[XMLNode]

            -- Short ends
            ((string (fromString "/>"))
                >>[PString, XMLNode] (result[XMLNode] (XMLElement tag attrs (Nil[XMLNode]))))))

and xmlElementChildren : Parser[PList[XMLNode]] =
    (xmlCData <$>[XMLNode, PList[XMLNode]] (\(c : XMLNode) -> singleton[XMLNode] c)
        <|>[PList[XMLNode]] (xmlText `using[XMLNode, PList[XMLNode]]` (\(n : XMLNode) -> singleton[XMLNode] n))
        <|>[PList[XMLNode]] (sepby1[XMLNode, Unit] xmlElement xmlSpace))
    <|>[PList[XMLNode]] (result[PList[XMLNode]] (Nil[XMLNode]));

let xmlProcInst : Parser[XMLNode] =
    (string (fromString "<?")) >>[PString, Unit] xmlSpace
        >>[Unit, PString] xmlKey >>=[PString, XMLNode] (\(target : PString) ->
            xmlSpace >>[Unit, PList[XMLNode]] xmlAttrs
                <*[PList[XMLNode], PString] (xmlSpace >>[Unit, PString] (string (fromString "?>")))
                    >>=[PList[XMLNode], XMLNode] (\(conts : PList[XMLNode]) ->
                        result[XMLNode] (XMLProcInst target conts)));

let parseXML : Parser[PList[XMLNode]] =
    (many[XMLNode] xmlProcInst)
        >>=[PList[XMLNode], PList[XMLNode]] (\(procinst1 : PList[XMLNode]) ->
            xmlElement >>=[XMLNode, PList[XMLNode]] (\(root : XMLNode) ->
                (many[XMLNode] xmlProcInst) >>=[PList[XMLNode], PList[XMLNode]] (\(procinst2 : PList[XMLNode]) ->
                    result[PList[XMLNode]] (procinst1 @[XMLNode] (root +>[XMLNode] procinst2)))));


-- Test

let println (s : String) : Unit = { java.lang.System.out.println(s); () };
let print (s : String) : Unit = { java.lang.System.out.print(s); () };

type TestFn = {
    name : String,
    fn   : Unit -> Unit
};

type TestSuite = {
    name : String,
    fns  : PList[TestFn]
};

let runTest (test : TestFn) : Unit = {
    let testingPrefix : String = "\u001b[31;1mtesting\u001b[0m\t";
    println testingPrefix.concat(test.name).concat(" :");
    test.fn ();
    println "\t...ok"
};

let runTests (tests : PList[TestFn]) : Unit =
    foldl[TestFn, Unit]
        (\(__ : Unit) (fn : TestFn) -> runTest fn) () tests;

let runTestSuite (suite : TestSuite) : Unit = {
    println "\n\t\u001b[32;1mRunning\u001b[37;1m ".concat(suite.name).concat("\u001b[0m ...\n");
    println "Running ".concat((len[TestFn] suite.fns).toString()).concat(" tests");
    runTests suite.fns
};

let runTestSuites (suites : PList[TestSuite]) : Unit =
    foldl[TestSuite, Unit]
        (\(__ : Unit) (suite : TestSuite) -> runTestSuite suite) () suites;

let error (msg : String) = {
    java.lang.System.err.println(msg);
    java.lang.System.exit(1);
    ()
};

-- Test helper functions

let assert (b : Bool) =
    if b then
        ()
    else
        error "assert failed!";

let printFirstXMLResult (r : PList[(XMLNode, PString)]) =
    case first[(XMLNode, PString)] r of
        Nothing        -> print "Nothing in the List!!"
     |  Just x         -> print "(".concat(xmlNodeToString x._1).concat(", \"").concat(toString x._2).concat("\")");

let intEqual (a : Int) (b : Int) : Bool    = a.equals(b);
let charEqual (a : Char) (b : Char) : Bool = a.equals(b);
let boolEqual (a : Bool) (b : Bool) : Bool = a.equals(b);

let firstParseResultEqual[A] (eq : Eq[A]) (r : PList[(A, PString)]) (expected : (A, PString)) : Bool =
    case first[(A, PString)] r of
        Nothing         -> False
     |  Just x          -> (eq x._1 expected._1) && (stringEqual x._2 expected._2);

-- Test utilities

let testListEqual : TestFn = {
    name = "listEqual",
    fn   = \(__ : Unit) -> assert (listEqual[Int]
                                        intEqual
                                        (singleton[Int] 1)
                                        (singleton[Int] 1))
};

let testMap : TestFn = {
    name = "map",
    fn   = \(__ : Unit) ->
        assert (listEqual[Char]
                    charEqual
                    (map[Char, Char] (\(c : Char) -> 'm') (fromString "hello"))
                    (fromString "mmmmm"))
};

let testFoldr : TestFn = {
    name = "foldr",
    fn   = \(__ : Unit) ->
        assert ((foldr[Int,Int] (\(a : Int) (b : Int) -> a + b) 0 (take[Int] 5 (nats 1))) == 15)
};

let testFoldl : TestFn = {
    name = "foldl",
    fn   = \(__ : Unit) ->
        assert ((foldl[Int,Int] (\(b : Int) (a : Int) -> a + b) 0 (take[Int] 5 (nats 1))) == 15)
};

let testUtilitiesSuite : TestSuite = {
    name = "Test Utilities",
    fns  = testListEqual
                +>[TestFn] (testMap
                +>[TestFn] (testFoldr
                +>[TestFn] (testFoldl
                +>[TestFn] (Nil[TestFn]))))
};

-- Test combinators

let testChar : TestFn = {
    name = "char 'a' (fromString \"abcd\")",
    fn   = \(__ : Unit) -> assert (parseResultEqual[Char]
                                      charEqual
                                      (char 'a' (fromString "abcd"))
                                      (singleton[(Char, PString)] ('a', (fromString "bcd"))))
};

let testUpper : TestFn = {
    name = "upper (fromString \"ABC\")",
    fn   = \(__ : Unit) -> assert (parseResultEqual[Char]
                                      charEqual
                                      (upper (fromString "ABC"))
                                      (singleton[(Char, PString)] ('A', (fromString "BC"))))
};

let testLetter : TestFn = {
    name = "letter (fromString \"abcd\")",
    fn   = \(__ : Unit) -> assert (parseResultEqual[Char]
                                      charEqual
                                      (letter (fromString "abcd"))
                                      (singleton[(Char, PString)] ('a', (fromString "bcd"))))
};

let testString : TestFn = {
    name = "string (fromString \"abc\") (fromString \"abcd\")",
    fn   = \(__ : Unit) -> assert (parseResultEqual[PString]
                                        stringEqual
                                        (string (fromString "abc") (fromString "abcd"))
                                        (singleton[(PString, PString)] ((fromString "abc"), (fromString "d"))))
};

let testMany : TestFn = {
    name = "many (char 'a') (fromString \"aaab\")",
    fn   = \(__ : Unit) -> {
        let expected = (fromString "aaa", fromString "b")
            +>[(PString, PString)] ((fromString "aa", fromString "ab")
            +>[(PString, PString)] ((fromString "a", fromString "aab")
            +>[(PString, PString)] ((fromString "", fromString "aaab")
            +>[(PString, PString)] (Nil[(PString, PString)]))));
        assert (parseResultEqual[PString]
                    stringEqual
                    (many[Char] (char 'a') (fromString "aaab"))
                    expected)
    }
};

let testMany1 : TestFn = {
    name = "many1 (char 'a') (fromString \"aaab\")",
    fn   = \(__ : Unit) -> {
        let expected = (fromString "aaa", fromString "b")
            +>[(PString, PString)] ((fromString "aa", fromString "ab")
            +>[(PString, PString)] ((fromString "a", fromString "aab")
            +>[(PString, PString)] (Nil[(PString, PString)])));
        assert (parseResultEqual[PString]
                    stringEqual
                    (many1[Char] (char 'a') (fromString "aaab"))
                    expected)
    }
};

let testChoice : TestFn = {
    name = "choice (char 'a') (char 'b') (fromString \"aaab\")",
    fn   = \(__ : Unit) ->
        assert (parseResultEqual[Char]
                    charEqual
                    (choice[Char] (char 'a') (char 'b') (fromString "aaab"))
                    (singleton[(Char, PString)] ('a', fromString "aab")))
};

let testChoice2 : TestFn = {
    name = "choice (string \"aa\") (string \"aaa\") (fromString \"aaab\")",
    fn   = \(__ : Unit) -> {
        let expected = (fromString "aa", fromString "ab")
            +>[(PString, PString)] ((fromString "aaa", fromString "b")
            +>[(PString, PString)] (Nil[(PString, PString)]));

        assert (parseResultEqual[PString]
                    stringEqual
                    (choice[PString] (string (fromString "aa")) (string (fromString "aaa")) (fromString "aaab"))
                    expected)
    }
};

let testWord : TestFn = {
    name = "word (fromString \"aaabcd abcd\")",
    fn   = \(__ : Unit) -> {
        let expected = (fromString "aaabcd", fromString " abcd")
            +>[(PString, PString)] ((fromString "aaabc", fromString "d abcd")
            +>[(PString, PString)] ((fromString "aaab", fromString "cd abcd")
            +>[(PString, PString)] ((fromString "aaa", fromString "bcd abcd")
            +>[(PString, PString)] ((fromString "aa", fromString "abcd abcd")
            +>[(PString, PString)] ((fromString "a", fromString "aabcd abcd")
            +>[(PString, PString)] (Nil[(PString, PString)]))))));
        assert (parseResultEqual[PString]
                    stringEqual
                    (word (fromString "aaabcd abcd"))
                    expected)
    }
};

let testNatural : TestFn = {
    name = "natural (fromString \"12345\")",
    fn   = \(__ : Unit) -> {
        let expected = (12345, fromString "")
            +>[(Int, PString)] ((1234, fromString "5")
            +>[(Int, PString)] ((123, fromString "45")
            +>[(Int, PString)] ((12, fromString "345")
            +>[(Int, PString)] ((1, fromString "2345")
            +>[(Int, PString)] (Nil[(Int, PString)])))));

        assert (parseResultEqual[Int]
                    intEqual
                    (natural (fromString "12345"))
                    expected)
    }
};

let testHexDecimal : TestFn = {
    name = "hexdecimal (fromString \"a0\")",
    fn   = \(__ : Unit) ->
         assert (firstParseResultEqual[Int]
                    intEqual
                    (hexdecimal (fromString "a0"))
                    (160, fromString ""))
};

let testSepby1 : TestFn = {
    name = "sepby1[PString, Char] word (char ',') (fromString \"abc,def\")",
    fn   = \(__ : Unit) ->
        assert (firstParseResultEqual[PList[PString]]
                    (listEqual[PString] stringEqual)
                    (sepby1[PString, Char] (word) (char ',') (fromString "abc,def"))
                    ((fromString "abc") +>[PString] ((fromString "def") +>[PString] (Nil[PString])),
                     (fromString "")))
};

let testNoneOf : TestFn = {
    name = "noneof (fromString \"abc\") (fromString \"dce\")",
    fn   = \(__ : Unit) ->
        assert (firstParseResultEqual[Char]
                    charEqual
                    (noneof (fromString "abc") (fromString "dce"))
                    ('d', fromString "ce"))
};

let testCombinatorsSuite : TestSuite = {
    name = "Test Combinators",
    fns  = testChar
                +>[TestFn] (testUpper
                +>[TestFn] (testLetter
                +>[TestFn] (testString
                +>[TestFn] (testMany
                +>[TestFn] (testMany1
                +>[TestFn] (testChoice
                +>[TestFn] (testChoice2
                +>[TestFn] (testWord
                +>[TestFn] (testNatural
                +>[TestFn] (testHexDecimal
                +>[TestFn] (testSepby1
                +>[TestFn] (Nil[TestFn]))))))))))))
};

-- Test Simple ARithmetic Expression Parser

let testSimpleExpr : TestFn = {
    name = "expr (fromString \"123\")",
    fn   = \(__ : Unit) ->
        assert (firstParseResultEqual[Int]
                    intEqual
                    (expr (fromString "123"))
                    (123, fromString ""))
};

let testSimpleExprWithBracket : TestFn = {
    name = "expr (fromString \"(123)\")",
    fn   = \(__ : Unit) ->
        assert (firstParseResultEqual[Int]
                    intEqual
                    (expr (fromString "(123)"))
                    (123, fromString ""))
};

let testSimpleExpr2 : TestFn = {
    name = "expr (fromString \"1+2\")",
    fn   = \(__ : Unit) ->
        assert (firstParseResultEqual[Int]
                    intEqual
                    (expr (fromString "1+2"))
                    (3, fromString ""))
};

let testSimpleExpr3 : TestFn = {
    name = "expr (fromString \"10+2\")",
    fn   = \(__ : Unit) ->
        assert (firstParseResultEqual[Int]
                    intEqual
                    (expr (fromString "10+2"))
                    (12, fromString ""))
};

let testSimpleExpr4 : TestFn = {
    name = "expr (fromString \"(10+2)*2\")",
    fn   = \(__ : Unit) ->
        assert (firstParseResultEqual[Int]
                    intEqual
                    (expr (fromString "(10+2)*2"))
                    (24, fromString ""))
};

let testSimpleExpr5 : TestFn = {
    name = "expr (fromString \"(10+2)*2/6\")",
    fn   = \(__ : Unit) ->
        assert (firstParseResultEqual[Int]
                    intEqual
                    (expr (fromString "(10+2)*2/6"))
                    (4, fromString ""))
};

let testSimpleArithmetricExprSuite : TestSuite = {
    name = "Test Simple Arithmetic Suite",
    fns  = testSimpleExpr
                +>[TestFn] (testSimpleExprWithBracket
                +>[TestFn] (testSimpleExpr2
                +>[TestFn] (testSimpleExpr3
                +>[TestFn] (testSimpleExpr4
                +>[TestFn] (testSimpleExpr5
                +>[TestFn] (Nil[TestFn]))))))
};

-- Test Naive XML Parser

let testXMLComment : TestFn = {
    name = "xmlComment (fromString \"<!-- hahaa? -->\")",
    fn   = \(__ : Unit) ->
        assert (firstParseResultEqual[XMLNode]
                    xmlNodeEqual
                    (xmlComment (fromString "<!-- hahaa? -->"))
                    ((XMLComment (fromString " hahaa? ")), fromString ""))
};

let testXMLDoubleQuotedString : TestFn = {
    name = "xmlDoubleQuotedString (fromString \"\\\"abcdef\\\"\")",
    fn   = \(__ : Unit) ->
        assert (firstParseResultEqual[PString]
                    stringEqual
                    (xmlDoubleQuotedString (fromString "\"abcdef\""))
                    (fromString "abcdef", fromString ""))
};

let testXMLSingleQuotedString : TestFn = {
    name = "xmlSingleQuotedString (fromString \"'abcdef'\")",
    fn   = \(__ : Unit) ->
        assert (firstParseResultEqual[PString]
                    stringEqual
                    (xmlSingleQuotedString (fromString "'abcdef'"))
                    ((fromString "abcdef"), (fromString "")))
};

let testXMLText : TestFn = {
    name = "xmlText (fromString \"abcdefg&lt;hijk\")",
    fn   = \(__ : Unit) ->
        assert (firstParseResultEqual[XMLNode]
                    xmlNodeEqual
                    (xmlText (fromString "abcdefg&lt;hijk"))
                    (XMLText (fromString "abcdefg<hijk"), fromString ""))
};

let testXMLTextEmpty : TestFn = {
    name = "xmlText (fromString \"\")",
    fn   = \(__ : Unit) ->
        assert (isempty[(XMLNode, PString)] (xmlText (fromString "")))
};

let testXMLAttr : TestFn = {
    name = "xmlAttr (fromString \"key = \"vvvalue\"\")",
    fn   = \(__ : Unit) ->
        assert (firstParseResultEqual[XMLNode]
                    xmlNodeEqual
                    (xmlAttr (fromString "key = \"vvvalue\""))
                    (XMLAttr (fromString "key") (fromString "vvvalue"), fromString ""))
};

let testXMLAttrs : TestFn = {
    name = "xmlAttrs (fromString \"key = \\\"vvvalue\\\" hello = \\\"world\\\" haha='what?'\")",
    fn   = \(__ : Unit) ->
        assert (firstParseResultEqual[PList[XMLNode]]
                    (listEqual[XMLNode] xmlNodeEqual)
                    (xmlAttrs (fromString "key = \"vvvalue\" hello = \"world\" haha='what?'"))
                    ((XMLAttr (fromString "key") (fromString "vvvalue"))
                        +>[XMLNode] ((XMLAttr (fromString "hello") (fromString "world"))
                        +>[XMLNode] ((XMLAttr (fromString "haha") (fromString "what?"))
                        +>[XMLNode] (Nil[XMLNode]))),
                     fromString ""))
};

let testElementSimple : TestFn = {
    name = "xmlElement (fromString \"<a></a>\")",
    fn   = \(__ : Unit) ->
        assert (firstParseResultEqual[XMLNode]
                    xmlNodeEqual
                    (xmlElement (fromString "<a></a>"))
                    (XMLElement (fromString "a") (Nil[XMLNode]) (Nil[XMLNode]), fromString ""))
};

let testElementWithText : TestFn = {
    name = "xmlElement (fromString \"<a>ha?haha!</a>\")",
    fn   = \(__ : Unit) ->
        assert (firstParseResultEqual[XMLNode]
                    xmlNodeEqual
                    (xmlElement (fromString "<a>ha?haha!</a>"))
                    (XMLElement (fromString "a") (Nil[XMLNode]) (singleton[XMLNode] (XMLText (fromString "ha?haha!"))),
                     fromString ""))
};

let testElementWithChildren : TestFn = {
    name = "xmlElement (fromString \"<a><b></b></a>\")",
    fn   = \(__ : Unit) ->
        assert (firstParseResultEqual[XMLNode]
                    xmlNodeEqual
                    (xmlElement (fromString "<a><b></b></a>"))
                    (XMLElement (fromString "a") (Nil[XMLNode])
                        (singleton[XMLNode] (XMLElement (fromString "b") (Nil[XMLNode]) (Nil[XMLNode]))),
                     fromString ""))
};

let testElementWithChildren2 : TestFn = {
    name = "xmlElement (fromString \"<a><b></b><c></c></a>\")",
    fn   = \(__ : Unit) -> {
        let b = XMLElement (fromString "b") (Nil[XMLNode]) (Nil[XMLNode]);
        let c = XMLElement (fromString "c") (Nil[XMLNode]) (Nil[XMLNode]);
        let a = XMLElement (fromString "a") (Nil[XMLNode]) (b +>[XMLNode] (c +>[XMLNode] (Nil[XMLNode])));
        assert (firstParseResultEqual[XMLNode]
                    xmlNodeEqual
                    (xmlElement (fromString "<a><b></b><c></c></a>"))
                    (a, fromString ""))
    }
};

let testElementWithAttr : TestFn = {
    name = "xmlElement (fromString \"<a href='/toosimple/sometimes/naive'>ha?haha!</a>\")",
    fn   = \(__ : Unit) -> {
        let elem = XMLElement
                        (fromString "a")
                        (singleton[XMLNode] (XMLAttr (fromString "href") (fromString "/toosimple/sometimes/naive")))
                        (singleton[XMLNode] (XMLText (fromString "ha?haha!")));
        assert (firstParseResultEqual[XMLNode]
                    xmlNodeEqual
                    (xmlElement (fromString "<a href='/toosimple/sometimes/naive'>ha?haha!</a>"))
                    (elem, fromString ""))
    }
};

let testElementWithAttrWithChildren : TestFn = {
    name = "xmlElement (fromString \"<a href='/toosimple/sometimes/naive'><b></b></a>\")",
    fn   = \(__ : Unit) -> {
        let elem = XMLElement
                        (fromString "a")
                        (singleton[XMLNode] (XMLAttr (fromString "href") (fromString "/toosimple/sometimes/naive")))
                        (singleton[XMLNode] (XMLElement (fromString "b") (Nil[XMLNode]) (Nil[XMLNode])));
        assert (firstParseResultEqual[XMLNode]
                    xmlNodeEqual
                    (xmlElement (fromString "<a href='/toosimple/sometimes/naive'><b></b></a>"))
                    (elem, fromString ""))
    }
};

let testElementSimple2 : TestFn = {
    name = "xmlElement (fromString \"<you young='too' simple='too'><naive>true</naive></you>\")",
    fn   = \(__ : Unit) -> {
        let elem = XMLElement
                        (fromString "you")
                        ((XMLAttr (fromString "young") (fromString "too"))
                            +>[XMLNode] ((XMLAttr (fromString "simple") (fromString "too"))
                            +>[XMLNode] (Nil[XMLNode])))
                        (singleton[XMLNode] (XMLElement (fromString "naive") (Nil[XMLNode])
                            (singleton[XMLNode] (XMLText (fromString "true")))));
        assert (firstParseResultEqual[XMLNode]
                    xmlNodeEqual
                    (xmlElement
                        (fromString
                            "<you young='too' simple='too'><naive>true</naive></you>"))
                    (elem, fromString ""))
    }
};

let testElementSimpleEndTag : TestFn = {
    name = "xmlElement (fromString \"<a/>\")",
    fn   = \(__ : Unit) -> {
        let elem = XMLElement (fromString "a") (Nil[XMLNode]) (Nil[XMLNode]);
        assert (firstParseResultEqual[XMLNode]
                    xmlNodeEqual
                    (xmlElement (fromString "<a/>"))
                    (elem, fromString ""))
    }
};

let testElementSimpleEndTag2 : TestFn = {
    name = "xmlElement (fromString \"<you young='too' simple='too'><naive><required/></naive></you>\")",
    fn   = \(__ : Unit) -> {
        let elem = XMLElement
                        (fromString "you")
                        ((XMLAttr (fromString "young") (fromString "too"))
                            +>[XMLNode] ((XMLAttr (fromString "simple") (fromString "too"))
                            +>[XMLNode] (Nil[XMLNode])))
                        (singleton[XMLNode] (XMLElement (fromString "naive") (Nil[XMLNode])
                            (singleton[XMLNode] (XMLElement (fromString "required") (Nil[XMLNode]) (Nil[XMLNode])))));
        assert (firstParseResultEqual[XMLNode]
                    xmlNodeEqual
                    (xmlElement
                        (fromString
                            "<you young='too' simple='too'><naive><required/></naive></you>"))
                    (elem, fromString ""))
    }
};

let testElementSimpleEndTag3 : TestFn = {
    name = "xmlElement (fromString \"<you young='too' simple='too'>\\n\\t<naive>\\n\\t\\t<required/>\\n\\t</naive>\\n</you>\")",
    fn   = \(__ : Unit) -> {
        let elem = XMLElement
                        (fromString "you")
                        ((XMLAttr (fromString "young") (fromString "too"))
                            +>[XMLNode] ((XMLAttr (fromString "simple") (fromString "too"))
                            +>[XMLNode] (Nil[XMLNode])))
                        (singleton[XMLNode] (XMLElement (fromString "naive") (Nil[XMLNode])
                            (singleton[XMLNode] (XMLElement (fromString "required") (Nil[XMLNode]) (Nil[XMLNode])))));

        assert (firstParseResultEqual[XMLNode]
                    xmlNodeEqual
                    (xmlElement
                        (fromString
                            "<you young='too' simple='too'>\n\t<naive>\n\t\t<required/>\n\t</naive>\n</you>"))
                    (elem, fromString ""))
    }
};

let testElementSimpleEndTag4 : TestFn = {
    name = "xmlElement (fromString \"<a href='https://github.com/hkuplg/fcore'/>\")",
    fn   = \(__ : Unit) -> {
        let elem = XMLElement
                        (fromString "a")
                        (singleton[XMLNode] (XMLAttr (fromString "href")
                                                     (fromString "https://github.com/hkuplg/fcore")))
                        (Nil[XMLNode]);
        assert (firstParseResultEqual[XMLNode]
                    xmlNodeEqual
                    (xmlElement (fromString "<a href='https://github.com/hkuplg/fcore'/>"))
                    (elem, fromString ""))
    }
};

let testCDataSimple : TestFn = {
    name = "xmlCData (fromString \"<![CDATA[function matchwo(a,b) { if (a < b && a < 0) then }]]>\"",
    fn   = \(__ : Unit) -> {
        let elem = XMLCData (fromString "function matchwo(a,b) { if (a < b && a < 0) then }");
        assert (firstParseResultEqual[XMLNode]
                    xmlNodeEqual
                    (xmlCData (fromString "<![CDATA[function matchwo(a,b) { if (a < b && a < 0) then }]]>"))
                    (elem, fromString ""))
    }
};

let testElementWithCData : TestFn = {
    name = "xmlElement (fromString \"<script><![CDATA[function matchwo(a,b) { &&<>!!!?; }]]></script>\"",
    fn   = \(__ : Unit) -> {
        let elem = XMLElement (fromString "script") (Nil[XMLNode])
                        (singleton[XMLNode] (XMLCData (fromString "function matchwo(a,b) { &&<>!!!?; }")));
        assert (firstParseResultEqual[XMLNode]
                    xmlNodeEqual
                    (xmlElement (fromString "<script><![CDATA[function matchwo(a,b) { &&<>!!!?; }]]></script>"))
                    (elem, fromString ""))
    }
};

let testProcInst : TestFn = {
    name = "xmlProcInst (fromString \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\")",
    fn   = \(__ : Unit) -> {
        let elem = XMLProcInst (fromString "xml")
                        ((XMLAttr (fromString "version") (fromString "1.0"))
                            +>[XMLNode] ((XMLAttr (fromString "encoding") (fromString "UTF-8"))
                            +>[XMLNode] (Nil[XMLNode])));
        assert (firstParseResultEqual[XMLNode]
                    xmlNodeEqual
                    (xmlProcInst (fromString "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>"))
                    (elem, fromString ""))
    }
};

let testProcInst2 : TestFn = {
    name = "xmlProcInst (fromString \"<?xml-stylesheet ?>\")",
    fn   = \(__ : Unit) -> {
        let elem = XMLProcInst (fromString "xml-stylesheet") (Nil[XMLNode]);
        assert (firstParseResultEqual[XMLNode]
                    xmlNodeEqual
                    (xmlProcInst (fromString "<?xml-stylesheet ?>"))
                    (elem, fromString ""))
    }
};

let testNaiveXMLParserSuite : TestSuite = {
    name = "Test Naive XML Parser",
    fns  = testXMLComment
                +>[TestFn] (testXMLDoubleQuotedString
                +>[TestFn] (testXMLSingleQuotedString
                +>[TestFn] (testXMLText
                +>[TestFn] (testXMLTextEmpty
                +>[TestFn] (testXMLAttr
                +>[TestFn] (testXMLAttrs
                +>[TestFn] (testElementSimple
                +>[TestFn] (testElementWithText
                +>[TestFn] (testElementWithChildren
                +>[TestFn] (testElementWithChildren2
                +>[TestFn] (testElementWithAttr
                +>[TestFn] (testElementWithAttrWithChildren
                +>[TestFn] (testElementSimple2
                +>[TestFn] (testElementSimpleEndTag
                +>[TestFn] (testElementSimpleEndTag2
                +>[TestFn] (testElementSimpleEndTag3
                +>[TestFn] (testElementSimpleEndTag4
                +>[TestFn] (testCDataSimple
                +>[TestFn] (testElementWithCData
                +>[TestFn] (testProcInst
                +>[TestFn] (testProcInst2
                +>[TestFn] (Nil[TestFn]))))))))))))))))))))))
};

let parserTestSuites : PList[TestSuite] =
    testUtilitiesSuite
        +>[TestSuite] (testCombinatorsSuite
        +>[TestSuite] (testSimpleArithmetricExprSuite
        +>[TestSuite] (testNaiveXMLParserSuite
        +>[TestSuite] (Nil[TestSuite]))));

{
    runTestSuites parserTestSuites;

    "\n-- END --"
}
