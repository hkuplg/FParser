{-#
    INCLUDE "parser_modular.sf"
    INCLUDE "pstring.sf"
    INCLUDE "testfx.sf"
#-}

-- F2J Parser

data F2JType = F2JNormalType    String PList[F2JType]
             | F2JPairedType    PList[F2JType]
             | F2JFunctionType  F2JType F2JType
             ;

let rec f2jTypeToString (t : F2JType) : String =
    case t of
        F2JNormalType name params ->
            "F2JNormalType \{name} \{pListToString[F2JType] f2jTypeToString params}"
     |  F2JPairedType types ->
            "F2JPairedType \{pListToString[F2JType] f2jTypeToString types}"
     |  F2JFunctionType from to ->
            "F2JFunctionType (\{f2jTypeToString from} -> \{f2jTypeToString to})";

let rec f2jTypeEq (a : F2JType) (b : F2JType) : Bool =
    case a of
        F2JNormalType n1 p1 -> {
            case b of
                F2JNormalType n2 p2 -> (n1 `stringEq` n2) && (pListEq[F2JType] f2jTypeEq p1 p2)
             |  F2JPairedType _     -> False
             |  F2JFunctionType _ _ -> False
        }
     |  F2JPairedType t1 -> {
            case b of
                F2JNormalType _ _   -> False
             |  F2JPairedType t2    -> pListEq[F2JType] f2jTypeEq t1 t2
             |  F2JFunctionType _ _ -> False
        }
     |  F2JFunctionType t1f t1t -> {
            case b of
                F2JNormalType _ _       -> False
             |  F2JPairedType _         -> False
             |  F2JFunctionType t2f t2t -> (t1f `f2jTypeEq` t2f) && (t1t `f2jTypeEq` t2t)
        };

data F2JBindingParam = F2JBindingParam String F2JType;

let f2jBindingParamToString (b : F2JBindingParam) : String =
    case b of
        F2JBindingParam id t ->
            "F2JBindingParam \{id} \{f2jTypeToString t}";

let f2jBindingParamEq (a : F2JBindingParam) (b : F2JBindingParam) : Bool =
    case a of
        F2JBindingParam ida ta ->
            case b of
                F2JBindingParam idb tb ->
                    (ida `stringEq` idb) && (ta `f2jTypeEq` tb);

data F2JCaseAlternative = F2JCaseAlternative String PList[String];

let f2jCaseAlternativeToString (c : F2JCaseAlternative) : String =
    case c of
        F2JCaseAlternative name args ->
            "F2JCaseAlternative \{name} \{pListToString[String] stringToString args}";

data F2JADTAlternative = F2JADTAlternative String PList[F2JType];

let f2jADTAlternativeToString (a : F2JADTAlternative) : String =
    case a of
        F2JADTAlternative name args ->
            "F2JADTAlternative \{name} \{pListToString[F2JType] f2jTypeToString args}";

data rec
    F2JBindingBody = F2JLetBindingBody     String PList[F2JType] PList[F2JBindingParam] Maybe[F2JType] F2JExpr
                   | F2JLetRecBindingBody  String PList[F2JType] PList[F2JBindingParam] F2JType F2JExpr

             -- Application     name    type params    expr
and  F2JExpr = F2JApplication   String  PList[F2JType] PList[F2JExpr]
             -- Let binding                            and           ; expr
             | F2JLet           F2JBindingBody         PList[F2JExpr] F2JExpr
             -- Let rec binding                        and           ; expr
             | F2JLetRec        F2JBindingBody         PList[F2JExpr] F2JExpr
             -- Lambda function params                 inner expr
             | F2JLambda        PList[F2JBindingParam] F2JExpr
             -- Infixop         op      left    right
             | F2JInfixOp       F2JType F2JExpr F2JExpr
             -- case of
             -- | F2JCase          F2JExpr PList[(F2JCaseAlternative, F2JExpr)]
             -- ADT
             | F2JADT           F2JType PList[F2JADTAlternative] F2JExpr
             -- Alias
             | F2JTypeAlias     F2JType F2JType F2JExpr
             -- Tuple
             | F2JPair          PList[F2JExpr]
             -- Int literal
             | F2JIntLiteral    String
             -- Double literal
             -- Long literal
             -- Short literal
             -- Byte literal
             -- String Literal
             | F2JStringLiteral String
             ;

let rec f2jBindingBodyToString (b : F2JBindingBody) : String =
    case b of
        F2JLetBindingBody name args params rettype expr ->
            "F2JLetBindingBody \{name} \{pListToString[F2JType] f2jTypeToString args} \{pListToString[F2JBindingParam] f2jBindingParamToString params} \{maybeToString[F2JType] f2jTypeToString rettype} \{f2jExprToString expr}"
     |  F2JLetRecBindingBody name args params rettype expr ->
            "F2JLetRecBindingBody \{name} \{pListToString[F2JType] f2jTypeToString args} \{pListToString[F2JBindingParam] f2jBindingParamToString params} \{f2jTypeToString rettype} \{f2jExprToString expr}"
and f2jExprToString (e : F2JExpr) : String =
    case e of
        F2JApplication name args expr ->
            "F2JApplication \{name} \{pListToString[F2JType] f2jTypeToString args} \{pListToString[F2JExpr] f2jExprToString expr}"
     |  F2JLet body andexpr expr ->
            "F2JLet \{f2jBindingBodyToString body} \{pListToString[F2JExpr] f2jExprToString andexpr} \{f2jExprToString expr}"
     |  F2JLetRec body andexpr expr ->
            "F2JLetRec \{f2jBindingBodyToString body} \{pListToString[F2JExpr] f2jExprToString andexpr} \{f2jExprToString expr}"
     |  F2JLambda params expr ->
            "F2JLambda \{pListToString[F2JBindingParam] f2jBindingParamToString params} \{f2jExprToString expr}"
     |  F2JInfixOp t left right ->
            "F2JInfixOp \{f2jTypeToString t} \{f2jExprToString left} \{f2jExprToString right}"
     |  F2JADT t alts expr ->
            "F2JADT \{f2jTypeToString t} \{pListToString[F2JADTAlternative] f2jADTAlternativeToString alts} \{f2jExprToString expr}"
     |  F2JTypeAlias t target expr ->
            "F2JTypeAlias \{f2jTypeToString t}, \{f2jTypeToString target}, \{f2jExprToString expr}"
     |  F2JPair conts ->
            "F2JPair \{pListToString[F2JExpr] f2jExprToString conts}"
     |  F2JIntLiteral s ->
            "F2JIntLiteral \{s}"
     |  F2JStringLiteral s ->
            "F2JStringLiteral \{s}"
     ;

data F2JComment = F2JLineComment String
                | F2JBlockComment String
                ;

let f2jCommentToString (tok : F2JComment) : String =
    case tok of
        F2JLineComment cmt         -> "F2JLineComment ".concat(cmt)
     |  F2JBlockComment cmt        -> "F2JBlockComment ".concat(cmt);

let f2jLineComment : Parser[F2JComment] =
    (string "--")
        *>[PString, PString]   (many[Char] (noneof "\r\n"))
        <*[PString, Unit]      (eol <|>[Unit] eof)
        <$>[PString, F2JComment] (\(cmt : PString) -> F2JLineComment (pStringToString cmt));

let f2jBlockComment : Parser[F2JComment] =
    let rec nested : Parser[PString] =
        (string "{-");

    (string "{-")
        *>[PString, PString] (many[Char] item) -- Need to support nested block comment
        <*[PString, PString] (string "-}")
        <$>[PString, F2JComment] (\(cmt : PString) -> F2JBlockComment (pStringToString cmt));

let f2jComment : Parser[F2JComment] =
    f2jLineComment <|>[F2JComment] f2jBlockComment;

let f2jSpace : Parser[Unit] =
    many[Char] whitespace $>[PList[Char], Unit] ();

let f2jInfixOpName : Parser[PString] =
    many1[Char] (oneof "!#$%&*+./<=>?@\\^|-~");

let f2jTypeName : Parser[PString] =
    upper                                           >>=[Char, PString]      (\(x : Char) ->
    (many[Char] (alphanum <|>[Char] (char '_')))    >>=[PString, PString]   (\(xs : PString) ->
    result[PString] (x +>[Char] xs)));

let rec f2jTypeParams : Parser[PList[F2JType]] =
    between[Unit, Unit, PList[F2JType]] ((char '[') >>[Char, Unit] f2jSpace) ((char ']') >>[Char, Unit] f2jSpace)
        (sepby1[F2JType, Unit] f2jType (f2jSpace >>[Unit, Char] (char ',') >>[Char, Unit] f2jSpace))
and f2jPairedType : Parser[F2JType] =
    between[Unit, Unit, F2JType] ((char '(') >>[Char, Unit] f2jSpace) ((char ')') >>[Char, Unit] f2jSpace)
        ((sepby1[F2JType, Unit] f2jType (f2jSpace >>[Unit, Char] (char ',') >>[Char, Unit] f2jSpace))
            >>=[PList[F2JType], F2JType] (\(types : PList[F2JType]) ->

                (f2jSpace >>[Unit, F2JType] f2jFunctionTypeRest >>=[F2JType, F2JType] (\(ftypeto : F2JType) ->
                    let ftypefrom = F2JPairedType types;
                    result[F2JType] (F2JFunctionType ftypefrom ftypeto)))
                <|>[F2JType]
                (result[F2JType] (F2JPairedType types))
            ))

and f2jSinglePairedType : Parser[F2JType] =
    between[Unit, Unit, F2JType] ((char '(') >>[Char, Unit] f2jSpace) ((char ')') >>[Char, Unit] f2jSpace)
        (f2jType >>=[F2JType, F2JType] (\(t : F2JType) ->

            (f2jSpace >>[Unit, F2JType] f2jFunctionTypeRest >>=[F2JType, F2JType] (\(ftypeto : F2JType) ->
                let ftypefrom = t;
                result[F2JType] (F2JFunctionType ftypefrom ftypeto)))
            <|>[F2JType]
                result[F2JType] t))

and f2jFunctionTypeRest : Parser[F2JType] =
    (string "->") >>[PString, Unit] f2jSpace >>[Unit, F2JType] f2jType

and f2jSingleType : Parser[F2JType] =
    (f2jTypeName)                                                                                                       >>=[PString, F2JType]        (\(typename : PString) ->
        ((f2jSpace >>[Unit, PList[F2JType]] f2jTypeParams) <|>[PList[F2JType]] (result[PList[F2JType]] (Nil[F2JType]))) >>=[PList[F2JType], F2JType] (\(tparams : PList[F2JType]) ->

            (f2jSpace >>[Unit, F2JType] f2jFunctionTypeRest >>=[F2JType, F2JType] (\(ftypeto : F2JType) ->
                let ftypefrom = F2JNormalType (pStringToString typename) tparams;
                result[F2JType] (F2JFunctionType ftypefrom ftypeto)))
            <|>[F2JType]
            (result[F2JType] (F2JNormalType (pStringToString typename) tparams))

        ))
and f2jNormalType : Parser[F2JType] =
    (f2jTypeName <*[PString, Unit] f2jSpace) >>=[PString, F2JType] (\(tstr : PString) ->
        ((f2jTypeParams <|>[PList[F2JType]] (result[PList[F2JType]] (Nil[F2JType]))) >>=[PList[F2JType], F2JType] (\(params : PList[F2JType]) ->
            result[F2JType] (F2JNormalType (pStringToString tstr) params))))

and f2jType : Parser[F2JType] =
        f2jSingleType
    <|>[F2JType]
        f2jSinglePairedType
    <|>[F2JType]
        f2jPairedType;

let f2jBindingParam : Parser[F2JBindingParam] =
    let seperator =
        f2jSpace >>[Unit, Char] (char ':') >>[Char, Unit] f2jSpace;

    let binding =
        (ident <*[PString, Unit] seperator) >>=[PString, F2JBindingParam] (\(id : PString) ->
            f2jType <$>[F2JType, F2JBindingParam] (\(t : F2JType) ->
            F2JBindingParam (pStringToString id) t));

    between[Unit, Unit, F2JBindingParam] ((char '(') >>[Char, Unit] f2jSpace) ((char ')') >>[Char, Unit] f2jSpace)
        binding;

let f2jBindingParams : Parser[PList[F2JBindingParam]] =
    sepby[F2JBindingParam, Unit] f2jBindingParam f2jSpace;

let f2jBindingName : Parser[PString] =
        ident
    <|>[PString]
        (((char '(') >>[Char, Unit] f2jSpace)
            >>[Unit, PString] f2jInfixOpName
            <*[PString, Char] (f2jSpace >>[Unit, Char] (char ')')));

let rec f2jIntLiterial : Parser[F2JExpr] =
    let nat : Parser[PString] =
        many1[Char] digit;
    (nat <|>[PString]
        (char '-' >>=[Char, PString]
            (\(minus : Char) -> nat >>=[PString, PString]
                (\(n : PString) -> result[PString] (minus +>[Char] n)))))
    <$>[PString, F2JExpr]
        (\(nstr : PString) -> F2JIntLiteral (pStringToString nstr));

let rec f2jTypeAlias : Parser[F2JExpr] =
    ((string "type") <*[PString, Unit] f2jSpace)
        >>[PString, F2JType] f2jNormalType >>=[F2JType, F2JExpr] (\(t : F2JType) ->
            (f2jSpace >>[Unit, Char] (char '=') >>[Char, Unit] f2jSpace)
                >>[Unit, F2JType] f2jType >>=[F2JType, F2JExpr] (\(tar : F2JType) ->
                    (f2jSpace >>[Unit, Char] (char ';') >>[Char, Unit] f2jSpace)
                        >>[Unit, F2JExpr] f2jExpr >>=[F2JExpr, F2JExpr] (\(expr : F2JExpr) ->
                            result[F2JExpr] (F2JTypeAlias t tar expr))))

and f2jADT : Parser[F2JExpr] =
    let f2jADTAlternative : Parser[F2JADTAlternative] =
        (f2jTypeName <*[PString, Unit] f2jSpace) >>=[PString, F2JADTAlternative] (\(tname : PString) ->
            (sepby[F2JType, Unit] f2jType f2jSpace) >>=[PList[F2JType], F2JADTAlternative] (\(types : PList[F2JType]) ->
                result[F2JADTAlternative] (F2JADTAlternative (pStringToString tname) types)));
    ((string "data") <*[PString, Unit] f2jSpace) >>[PString, F2JType]
        (f2jNormalType <*[F2JType, Unit] (f2jSpace >>[Unit, Char] (char '=') >>[Char, Unit] f2jSpace)) >>=[F2JType, F2JExpr] (\(t : F2JType) ->
            (sepby1[F2JADTAlternative, Unit] f2jADTAlternative (f2jSpace >>[Unit, Char] (char '|') >>[Char, Unit] f2jSpace)) >>=[PList[F2JADTAlternative], F2JExpr] (\(alts : PList[F2JADTAlternative]) ->
                (f2jSpace >>[Unit, Char] (char ';') >>[Char, Unit] f2jSpace) >>[Unit, F2JExpr] f2jExpr >>=[F2JExpr, F2JExpr] (\(expr : F2JExpr) ->
                    (result[F2JExpr] (F2JADT t alts expr)))))
and f2jPair : Parser[F2JExpr] =
    (char '(' >>[Char, Unit] f2jSpace)
        *>[Unit, PList[F2JExpr]] (sepby[F2JExpr, Unit] f2jExpr (f2jSpace >>[Unit, Char] (char ',') >>[Char, Unit] f2jSpace))
        <*[PList[F2JExpr], Char] (f2jSpace >>[Unit, Char] (char ')'))
        <$>[PList[F2JExpr], F2JExpr] (\(exprs : PList[F2JExpr]) -> F2JPair exprs)

and f2jLambda : Parser[F2JExpr] =
    ((char '\\') >>[Char, Unit] f2jSpace)
        >>[Unit, PList[F2JBindingParam]] f2jBindingParams >>=[PList[F2JBindingParam], F2JExpr] (\(params : PList[F2JBindingParam]) ->
            (f2jSpace >>[Unit, PString] (string "->") >>[PString, Unit] f2jSpace >>[Unit, F2JExpr] f2jExpr
                >>=[F2JExpr, F2JExpr] (\(expr : F2JExpr) ->
                    result[F2JExpr] (F2JLambda params expr))))

-- let rec f2jApplication : Parser[F2JExpr] =
--     let f2jWrapedApplication : Parser[F2JExpr] =
--         between[Unit, Unit, F2JExpr] ((char '(') >>[Char, Unit] f2jSpace) ((char ')') >>[Char, Unit] f2jSpace)
--             f2jApplication;

--     result[F2JExpr] (F2JApplication "" (Nil[F2JType]) (Nil[F2JExpr]))

-- and f2jLetBinding : Parser[F2JBindingBody] =
--     ((f2jBindingName <*[PString, Unit] f2jSpace) >>=[PString, F2JBindingBody] (\(name : PString) ->
--         ((f2jTypeParams <|>[PList[F2JType]] (result[PList[F2JType]] (Nil[F2JType]))) <*[PList[F2JType], Unit] f2jSpace >>=[PList[F2JType], F2JBindingBody] (\(tparams : PList[F2JType]) ->
--             f2jBindingParams <*[PList[F2JBindingParam], Unit] f2jSpace >>=[PList[F2JBindingParam], F2JBindingBody] (\(params : PList[F2JBindingParam]) ->
--                 (((char ':') >>[Char, Unit] f2jSpace >>[Unit, F2JType] f2jType <$>[F2JType, Maybe[F2JType]] (\(rettype : F2JType) -> Just[F2JType] rettype))
--                 <|>[Maybe[F2JType]] (result[Maybe[F2JType]] (Nothing[F2JType]))) <*[Maybe[F2JType], Unit] f2jSpace >>=[Maybe[F2JType], F2JBindingBody] (\(rettype : Maybe[F2JType]) ->
--                     (char '=') >>[Char, Unit] f2jSpace >>[Unit, F2JExpr] f2jExpr (\(toExpr : F2JExpr) ->
--                         result[F2JBindingBody] (F2JLetBindingBody (pStringToString name) tparams params rettype toExpr))))))))

and f2jExpr : Parser[F2JExpr] =
        f2jIntLiterial
    <|>[F2JExpr]
        f2jTypeAlias
    <|>[F2JExpr]
        f2jADT
    <|>[F2JExpr]
        f2jPair;

{

    -- println (parseOutputToString[F2JComment]
    --             f2jCommentToString
    --             (f2jComment `parsePString[F2JComment]` (pStringFromString "-- abchahaha")));

    -- println (parseOutputToString[F2JComment]
    --             f2jCommentToString
    --             (f2jComment `parsePString[F2JComment]` (pStringFromString "-- abchahaha\n-- second line\nnormal")));

    -- println (parseOutputToString[F2JComment]
    --             f2jCommentToString
    --             (f2jComment `parsePString[F2JComment]` (pStringFromString "{- abchahaha -}")));

    -- println (parseOutputToString[Unit]
    --             unitToString
    --             (eol `parsePString[Unit]` (pStringFromString "\nabcde")));

    -- println (parseOutputToString[F2JType]
    --             f2jTypeToString
    --             (f2jType `parsePString[F2JType]` (pStringFromString "A[B, C[D]]")));

    -- println (parseOutputToString[F2JType]
    --             f2jTypeToString
    --             (f2jType `parsePString[F2JType]` (pStringFromString "(A, B)")));

    -- println (parseOutputToString[F2JBindingParam]
    --             f2jBindingParamToString
    --             (f2jBindingParam `parsePString[F2JBindingParam]` (pStringFromString "(a : PList[A])")));

    -- println (parseOutputToString[PList[F2JBindingParam]]
    --             (pListToString[F2JBindingParam] f2jBindingParamToString)
    --             (f2jBindingParams `parsePString[PList[F2JBindingParam]]` (pStringFromString "(a : PList[A]) (b : PString)")));

    -- println (parseOutputToString[PString]
    --             pStringToString
    --             (f2jBindingName `parseString[PString]` "parseOutputToString"));

    -- println (parseOutputToString[PString]
    --             pStringToString
    --             (f2jBindingName `parseString[PString]` "(<!>)"));

    -- println (parseOutputToString[F2JType]
    --             f2jTypeToString
    --             (f2jType `parsePString[F2JType]` (pStringFromString "((A))")));

    -- println (parseOutputToString[F2JType]
    --             f2jTypeToString
    --             (f2jType `parsePString[F2JType]` (pStringFromString "(A[C] -> B)")));

    -- println (parseOutputToString[F2JExpr]
    --             f2jExprToString
    --             (f2jIntLiterial `parseString[F2JExpr]` "123"));

    -- println (parseOutputToString[F2JExpr]
    --             f2jExprToString
    --             (f2jTypeAlias `parseString[F2JExpr]` "type Ha[A] = Fucker; 123"));

    -- println (parseOutputToString[F2JExpr]
    --             f2jExprToString
    --             (f2jADT `parseString[F2JExpr]` "data PList[A] = Nil | Cons A (PList[A]); 1"));

    println (parseOutputToString[F2JExpr]
                f2jExprToString
                (f2jPair `parseString[F2JExpr]` "(1,2,3)"));

    println (parseOutputToString[F2JExpr]
                f2jExprToString
                (f2jLambda `parseString[F2JExpr]` "\\(a : A) -> 1"));

    "\n-- END --"
}
